"use strict";(self.webpackChunknimbly=self.webpackChunknimbly||[]).push([[9133],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return k}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),k=a,h=d["".concat(l,".").concat(k)]||d[k]||u[k]||i;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7952:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={title:"Using multiple nodes",sidebar_position:7,slug:"/using-multiple-nodes/"},l=void 0,c={unversionedId:"categories/Server/using-multiple-nodes",id:"categories/Server/using-multiple-nodes",title:"Using multiple nodes",description:"When deploying multiple Socket.IO servers, there are two things to take care of:",source:"@site/docs/categories/02-Server/using-multiple-nodes.md",sourceDirName:"categories/02-Server",slug:"/using-multiple-nodes/",permalink:"/nimbly/docs/v1/using-multiple-nodes/",tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Using multiple nodes",sidebar_position:7,slug:"/using-multiple-nodes/"},sidebar:"sidebar",previous:{title:"Behind a reverse proxy",permalink:"/nimbly/docs/v1/reverse-proxy/"},next:{title:"Handling CORS",permalink:"/nimbly/docs/v1/handling-cors/"}},p=[{value:"Sticky load balancing",id:"sticky-load-balancing",children:[{value:"Why is sticky-session required",id:"why-is-sticky-session-required",children:[],level:3},{value:"Enabling sticky-session",id:"enabling-sticky-session",children:[],level:3},{value:"NginX configuration",id:"nginx-configuration",children:[],level:3},{value:"Apache HTTPD configuration",id:"apache-httpd-configuration",children:[],level:3},{value:"HAProxy configuration",id:"haproxy-configuration",children:[],level:3},{value:"Traefik",id:"traefik",children:[],level:3},{value:"Using Node.js Cluster",id:"using-nodejs-cluster",children:[],level:3}],level:2},{value:"Passing events between nodes",id:"passing-events-between-nodes",children:[],level:2}],u={toc:p};function d(e){var t=e.components,s=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When deploying multiple Socket.IO servers, there are two things to take care of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"enabling sticky session, if HTTP long-polling is enabled (which is the default): see ",(0,i.kt)("a",{parentName:"li",href:"#enabling-sticky-session"},"below")),(0,i.kt)("li",{parentName:"ul"},"using a compatible adapter, see ",(0,i.kt)("a",{parentName:"li",href:"../05-Adapters/adapter.md"},"here"))),(0,i.kt)("h2",{id:"sticky-load-balancing"},"Sticky load balancing"),(0,i.kt)("p",null,"If you plan to distribute the load of connections among different processes or machines, you have to make sure that all requests associated with a particular session ID reach the process that originated them."),(0,i.kt)("h3",{id:"why-is-sticky-session-required"},"Why is sticky-session required"),(0,i.kt)("p",null,"This is because the HTTP long-polling transport sends multiple HTTP requests during the lifetime of the Socket.IO session."),(0,i.kt)("p",null,"In fact, Socket.IO could technically work without sticky sessions, with the following synchronization (in dashed lines):"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Using multiple nodes without sticky sessions",src:n(2350).Z,width:"1271",height:"620"})),(0,i.kt)("p",null,"While obviously possible to implement, we think that this synchronization process between the Socket.IO servers would result in a big performance hit for your application."),(0,i.kt)("p",null,"Remarks:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'without enabling sticky-session, you will experience HTTP 400 errors due to "Session ID unknown"'),(0,i.kt)("li",{parentName:"ul"},"the WebSocket transport does not have this limitation, since it relies on a single TCP connection for the whole session. Which means that if you disable the HTTP long-polling transport (which is a perfectly valid choice in 2021), you won't need sticky sessions:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const socket = io("https://io.yourhost.com", {\n  // WARNING: in that case, there is no fallback to long-polling\n  transports: [ "websocket" ] // or [ "websocket", "polling" ] (the order matters)\n});\n')),(0,i.kt)("p",null,"Documentation: ",(0,i.kt)("a",{parentName:"p",href:"/nimbly/docs/v1/client-options/#transports"},(0,i.kt)("inlineCode",{parentName:"a"},"transports"))),(0,i.kt)("h3",{id:"enabling-sticky-session"},"Enabling sticky-session"),(0,i.kt)("p",null,"To achieve sticky-session, there are two main solutions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"routing clients based on a cookie (recommended solution)"),(0,i.kt)("li",{parentName:"ul"},"routing clients based on their originating address")),(0,i.kt)("p",null,"You will find below some examples with common load-balancing solutions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#nginx-configuration"},"NginX")," (IP-based)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#apache-httpd-configuration"},"Apache HTTPD")," (cookie-based)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#haproxy-configuration"},"HAProxy")," (cookie-based)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#traefik"},"Traefik")," (cookie-based)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#using-nodejs-cluster"},"Node.js ",(0,i.kt)("inlineCode",{parentName:"a"},"cluster")," module"))),(0,i.kt)("p",null,"For other platforms, please refer to the relevant documentation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Kubernetes: ",(0,i.kt)("a",{parentName:"li",href:"https://kubernetes.github.io/ingress-nginx/examples/affinity/cookie/"},"https://kubernetes.github.io/ingress-nginx/examples/affinity/cookie/")),(0,i.kt)("li",{parentName:"ul"},"AWS (Application Load Balancers): ",(0,i.kt)("a",{parentName:"li",href:"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html"},"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html")),(0,i.kt)("li",{parentName:"ul"},"GCP: ",(0,i.kt)("a",{parentName:"li",href:"https://cloud.google.com/load-balancing/docs/backend-service#session_affinity"},"https://cloud.google.com/load-balancing/docs/backend-service#session_affinity")),(0,i.kt)("li",{parentName:"ul"},"Heroku: ",(0,i.kt)("a",{parentName:"li",href:"https://devcenter.heroku.com/articles/session-affinity"},"https://devcenter.heroku.com/articles/session-affinity"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Important note"),": if you are in a CORS situation (the front domain is different from the server domain) and session affinity is achieved with a cookie, you need to allow credentials:"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Server")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const io = require("socket.io")(httpServer, {\n  cors: {\n    origin: "https://front-domain.com",\n    methods: ["GET", "POST"],\n    credentials: true\n  }\n});\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Client")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const io = require("socket.io-client");\nconst socket = io("https://server-domain.com", {\n  withCredentials: true\n});\n')),(0,i.kt)("p",null,'Without it, the cookie will not be sent by the browser and you will experience HTTP 400 "Session ID unknown" responses. More information ',(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials"},"here"),"."),(0,i.kt)("h3",{id:"nginx-configuration"},"NginX configuration"),(0,i.kt)("p",null,"Within the ",(0,i.kt)("inlineCode",{parentName:"p"},"http { }")," section of your ",(0,i.kt)("inlineCode",{parentName:"p"},"nginx.conf")," file, you can declare a ",(0,i.kt)("inlineCode",{parentName:"p"},"upstream")," section with a list of Socket.IO process you want to balance load between:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-nginx"},'http {\n  server {\n    listen 3000;\n    server_name io.yourhost.com;\n\n    location / {\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n      proxy_set_header Host $host;\n\n      proxy_pass http://nodes;\n\n      # enable WebSockets\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection "upgrade";\n    }\n  }\n\n  upstream nodes {\n    # enable sticky session with either "hash" (uses the complete IP address)\n    hash $remote_addr consistent;\n    # or "ip_hash" (uses the first three octets of the client IPv4 address, or the entire IPv6 address)\n    # ip_hash;\n    # or "sticky" (needs commercial subscription)\n    # sticky cookie srv_id expires=1h domain=.example.com path=/;\n\n    server app01:3000;\n    server app02:3000;\n    server app03:3000;\n  }\n}\n')),(0,i.kt)("p",null,"Notice the ",(0,i.kt)("inlineCode",{parentName:"p"},"hash")," instruction that indicates the connections will be sticky."),(0,i.kt)("p",null,"Make sure you also configure ",(0,i.kt)("inlineCode",{parentName:"p"},"worker_processes")," in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the ",(0,i.kt)("inlineCode",{parentName:"p"},"worker_connections")," setting within the ",(0,i.kt)("inlineCode",{parentName:"p"},"events { }")," block."),(0,i.kt)("p",null,"Links:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/socketio/socket.io/tree/master/examples/cluster-nginx"},"Example")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash"},"NginX Documentation"))),(0,i.kt)("h3",{id:"apache-httpd-configuration"},"Apache HTTPD configuration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-apache"},'Header add Set-Cookie "SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED\n\n<Proxy "balancer://nodes_polling">\n    BalancerMember "http://app01:3000" route=app01\n    BalancerMember "http://app02:3000" route=app02\n    BalancerMember "http://app03:3000" route=app03\n    ProxySet stickysession=SERVERID\n</Proxy>\n\n<Proxy "balancer://nodes_ws">\n    BalancerMember "ws://app01:3000" route=app01\n    BalancerMember "ws://app02:3000" route=app02\n    BalancerMember "ws://app03:3000" route=app03\n    ProxySet stickysession=SERVERID\n</Proxy>\n\nRewriteEngine On\nRewriteCond %{HTTP:Upgrade} =websocket [NC]\nRewriteRule /(.*) balancer://nodes_ws/$1 [P,L]\nRewriteCond %{HTTP:Upgrade} !=websocket [NC]\nRewriteRule /(.*) balancer://nodes_polling/$1 [P,L]\n\nProxyTimeout 3\n')),(0,i.kt)("p",null,"Links:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/socketio/socket.io/tree/master/examples/cluster-httpd"},"Example")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://httpd.apache.org/docs/2.4/en/mod/mod_proxy.html#proxypass"},"Documentation"))),(0,i.kt)("h3",{id:"haproxy-configuration"},"HAProxy configuration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"# Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/\n\nlisten chat\n  bind *:80\n  default_backend nodes\n\nbackend nodes\n  option httpchk HEAD /health\n  http-check expect status 200\n  cookie io prefix indirect nocache # using the `io` cookie set upon handshake\n  server app01 app01:3000 check cookie app01\n  server app02 app02:3000 check cookie app02\n  server app03 app03:3000 check cookie app03\n")),(0,i.kt)("p",null,"Links:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/socketio/socket.io/tree/master/examples/cluster-haproxy"},"Example")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://cbonte.github.io/haproxy-dconv/2.4/configuration.html#cookie"},"Documentation"))),(0,i.kt)("h3",{id:"traefik"},"Traefik"),(0,i.kt)("p",null,"Using container labels:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'# docker-compose.yml\nservices:\n  traefik:\n    image: traefik:2.4\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    links:\n      - server\n\n  server:\n    image: my-image:latest\n    labels:\n      - "traefik.http.routers.my-service.rule=PathPrefix(`/`)"\n      - traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id\n      - traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true\n')),(0,i.kt)("p",null,"With the ",(0,i.kt)("a",{parentName:"p",href:"https://doc.traefik.io/traefik/v2.0/providers/file/"},"File provider"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'## Dynamic configuration\nhttp:\n  services:\n    my-service:\n      rule: "PathPrefix(`/`)"\n      loadBalancer:\n        sticky:\n          cookie:\n            name: server_id\n            httpOnly: true\n')),(0,i.kt)("p",null,"Links:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/socketio/socket.io/tree/master/examples/cluster-traefik"},"Example")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://doc.traefik.io/traefik/v2.0/routing/services/#sticky-sessions"},"Documentation"))),(0,i.kt)("h3",{id:"using-nodejs-cluster"},"Using Node.js Cluster"),(0,i.kt)("p",null,"Just like NginX, Node.js comes with built-in clustering support through the ",(0,i.kt)("inlineCode",{parentName:"p"},"cluster")," module."),(0,i.kt)("p",null,"There are several solutions, depending on your use case:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"NPM package"),(0,i.kt)("th",{parentName:"tr",align:null},"How it works"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/darrachequesne/socket.io-sticky"},(0,i.kt)("inlineCode",{parentName:"a"},"@socket.io/sticky"))),(0,i.kt)("td",{parentName:"tr",align:null},"the routing is based on the ",(0,i.kt)("inlineCode",{parentName:"td"},"sid")," query parameter")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/indutny/sticky-session"},(0,i.kt)("inlineCode",{parentName:"a"},"sticky-session"))),(0,i.kt)("td",{parentName:"tr",align:null},"the routing is based on ",(0,i.kt)("inlineCode",{parentName:"td"},"connection.remoteAddress"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/wzrdtales/socket-io-sticky-session"},(0,i.kt)("inlineCode",{parentName:"a"},"socketio-sticky-session"))),(0,i.kt)("td",{parentName:"tr",align:null},"the routing based on the ",(0,i.kt)("inlineCode",{parentName:"td"},"x-forwarded-for")," header)")))),(0,i.kt)("p",null,"Example with ",(0,i.kt)("inlineCode",{parentName:"p"},"@socket.io/sticky"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const cluster = require("cluster");\nconst http = require("http");\nconst { Server } = require("socket.io");\nconst numCPUs = require("os").cpus().length;\nconst { setupMaster, setupWorker } = require("@socket.io/sticky");\nconst { createAdapter, setupPrimary } = require("@socket.io/cluster-adapter");\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  const httpServer = http.createServer();\n\n  // setup sticky sessions\n  setupMaster(httpServer, {\n    loadBalancingMethod: "least-connection",\n  });\n\n  // setup connections between the workers\n  setupPrimary();\n\n  // needed for packets containing buffers (you can ignore it if you only send plaintext objects)\n  // Node.js < 16.0.0\n  cluster.setupMaster({\n    serialization: "advanced",\n  });\n  // Node.js > 16.0.0\n  // cluster.setupPrimary({\n  //   serialization: "advanced",\n  // });\n\n  httpServer.listen(3000);\n\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on("exit", (worker) => {\n    console.log(`Worker ${worker.process.pid} died`);\n    cluster.fork();\n  });\n} else {\n  console.log(`Worker ${process.pid} started`);\n\n  const httpServer = http.createServer();\n  const io = new Server(httpServer);\n\n  // use the cluster adapter\n  io.adapter(createAdapter());\n\n  // setup connection with the primary process\n  setupWorker(io);\n\n  io.on("connection", (socket) => {\n    /* ... */\n  });\n}\n')),(0,i.kt)("h2",{id:"passing-events-between-nodes"},"Passing events between nodes"),(0,i.kt)("p",null,"Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to all clients (or to the clients in a certain ",(0,i.kt)("a",{parentName:"p",href:"../04-Events/rooms.md"},"room"),") you","\u2019","ll need some way of passing messages between processes or computers."),(0,i.kt)("p",null,"The interface in charge of routing messages is what we call the ",(0,i.kt)("a",{parentName:"p",href:"../05-Adapters/adapter.md"},"Adapter"),"."))}d.isMDXComponent=!0},2350:function(e,t,n){t.Z=n.p+"assets/images/mutiple-nodes-no-sticky-babd7860f217e09eefc2db73e5012f91.png"}}]);