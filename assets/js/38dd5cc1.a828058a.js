"use strict";(self.webpackChunknimbly=self.webpackChunknimbly||[]).push([[9819],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var s=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,s,r=function(e,t){if(null==e)return{};var n,s,r={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=s.createContext({}),p=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return s.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},d=s.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||a;return n?s.createElement(h,i(i({ref:t},c),{},{components:n})):s.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var p=2;p<a;p++)i[p]=n[p];return s.createElement.apply(null,i)}return s.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9420:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return c}});var s=n(7462),r=n(3366),a=(n(7294),n(3905)),i=["components"],o={title:"Private messaging - Part IV"},l="Private messaging - Part IV",p={type:"mdx",permalink:"/get-started/private-messaging-part-4",source:"@site/src/pages/get-started/private-messaging-part-4.md",title:"Private messaging - Part IV",description:"This guide has four distinct parts:",frontMatter:{title:"Private messaging - Part IV"}},c=[{value:"Installation",id:"installation",children:[],level:2},{value:"Updating the server",id:"updating-the-server",children:[],level:2},{value:"How it works",id:"how-it-works",children:[{value:"Creating multiple servers",id:"creating-multiple-servers",children:[],level:3},{value:"Sessions &amp; messages",id:"sessions--messages",children:[],level:3},{value:"Forwarding messages",id:"forwarding-messages",children:[],level:3}],level:2},{value:"Review",id:"review",children:[],level:2}],u={toc:c};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,s.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"private-messaging---part-iv"},"Private messaging - Part IV"),(0,a.kt)("p",null,"This guide has four distinct parts:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/get-started/private-messaging-part-1/"},"Part I"),": initial implementation"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/get-started/private-messaging-part-2/"},"Part II")," : persistent user ID"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/get-started/private-messaging-part-3/"},"Part III")," : persistent messages"),(0,a.kt)("li",{parentName:"ul"},"Part IV ",(0,a.kt)("strong",{parentName:"li"},"(current)"),": scaling up")),(0,a.kt)("p",null,"Here's where we were at the end of the ",(0,a.kt)("a",{parentName:"p",href:"/get-started/private-messaging-part-2/"},"3rd part"),":"),(0,a.kt)("img",{src:"/images/private-messaging-part-2-chat.gif",alt:"Chat"}),(0,a.kt)("p",null,"We will see now how we can scale to multiple Socket.IO servers, for high availability / load-balancing purposes."),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"Let's checkout the branch for part IV:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"git checkout examples/private-messaging-part-4\n")),(0,a.kt)("p",null,"Here's what you should see in the current directory:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\u251c\u2500\u2500 babel.config.js\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 public\n\u2502   \u251c\u2500\u2500 favicon.ico\n\u2502   \u251c\u2500\u2500 fonts\n\u2502   \u2502   \u2514\u2500\u2500 Lato-Regular.ttf\n\u2502   \u2514\u2500\u2500 index.html\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 server\n\u2502   \u251c\u2500\u2500 cluster.js (created)\n\u2502   \u251c\u2500\u2500 docker-compose.yml (created)\n\u2502   \u251c\u2500\u2500 index.js (updated)\n\u2502   \u251c\u2500\u2500 messageStore.js (updated)\n\u2502   \u251c\u2500\u2500 package.json (updated)\n\u2502   \u2514\u2500\u2500 sessionStore.js (updated)\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 App.vue\n    \u251c\u2500\u2500 components\n    \u2502   \u251c\u2500\u2500 Chat.vue\n    \u2502   \u251c\u2500\u2500 MessagePanel.vue\n    \u2502   \u251c\u2500\u2500 SelectUsername.vue\n    \u2502   \u251c\u2500\u2500 StatusIcon.vue\n    \u2502   \u2514\u2500\u2500 User.vue\n    \u251c\u2500\u2500 main.js\n    \u2514\u2500\u2500 socket.js\n")),(0,a.kt)("p",null,"The complete diff can be found ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/socketio/socket.io/compare/examples/private-messaging-part-3...examples/private-messaging-part-4"},"here"),"."),(0,a.kt)("h2",{id:"updating-the-server"},"Updating the server"),(0,a.kt)("p",null,"For this last part, we need 3 additional dependencies on the server-side:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/ioredis"},(0,a.kt)("inlineCode",{parentName:"a"},"ioredis")),": a great Redis client"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/socket.io-redis"},(0,a.kt)("inlineCode",{parentName:"a"},"socket.io-redis")),": a Socket.IO adapter based on Redis ",(0,a.kt)("a",{parentName:"li",href:"https://redis.io/topics/pubsub"},"pub/sub mechanism")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/@socket.io/sticky"},(0,a.kt)("inlineCode",{parentName:"a"},"@socket.io/sticky")),": a module for running Socket.IO within a Node.js ",(0,a.kt)("a",{parentName:"li",href:"https://nodejs.org/api/cluster.html"},"cluster"))),(0,a.kt)("p",null,"We also need a Redis instance. For your convenience, a ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.yml")," file is provided:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"cd server\ndocker-compose up -d\n\nnpm install\nnpm start\n")),(0,a.kt)("p",null,"This will create 4 Node.js workers, each running the same ",(0,a.kt)("inlineCode",{parentName:"p"},"index.js")," file."),(0,a.kt)("p",null,"On the client-side, no change is needed, we will focus on the server-side here."),(0,a.kt)("h2",{id:"how-it-works"},"How it works"),(0,a.kt)("h3",{id:"creating-multiple-servers"},"Creating multiple servers"),(0,a.kt)("p",null,"When creating multiple Socket.IO servers, there are two things to do:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"you need to enable sticky-session (please see ",(0,a.kt)("a",{parentName:"li",href:"/docs/v4/using-multiple-nodes/#Sticky-load-balancing"},"here")," for the complete explanation)"),(0,a.kt)("li",{parentName:"ul"},"you need to replace the default in-memory adapter with the Redis adapter (or another compatible adapter)")),(0,a.kt)("p",null,"In our example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"@socket.io/sticky"),' module is used to ensure that requests from a given client are always routed to the same Socket.IO server. This is what is called "sticky-session":'),(0,a.kt)("img",{src:"/images/private-messaging-part-4-sticky-session.png",alt:"Sticky session"}),(0,a.kt)("p",null,"Note: we could also have created several processes listening to different ports (or used multiple hosts), and add a reverse-proxy in front of them. Enabling sticky-session for common reverse-proxy solutions like NginX or HAProxy is covered in the ",(0,a.kt)("a",{parentName:"p",href:"/docs/v4/using-multiple-nodes/#Sticky-load-balancing"},"documentation"),"."),(0,a.kt)("p",null,"The cluster is created in the ",(0,a.kt)("inlineCode",{parentName:"p"},"server/cluster.js")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const cluster = require("cluster");\nconst http = require("http");\nconst { setupMaster } = require("@socket.io/sticky");\n\nconst WORKERS_COUNT = 4;\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  for (let i = 0; i < WORKERS_COUNT; i++) {\n    cluster.fork();\n  }\n\n  cluster.on("exit", (worker) => {\n    console.log(`Worker ${worker.process.pid} died`);\n    cluster.fork();\n  });\n\n  const httpServer = http.createServer();\n  setupMaster(httpServer, {\n    loadBalancingMethod: "least-connection", // either "random", "round-robin" or "least-connection"\n  });\n  const PORT = process.env.PORT || 3000;\n\n  httpServer.listen(PORT, () =>\n    console.log(`server listening at http://localhost:${PORT}`)\n  );\n} else {\n  console.log(`Worker ${process.pid} started`);\n  require("./index");\n}\n')),(0,a.kt)("p",null,"In our existing ",(0,a.kt)("inlineCode",{parentName:"p"},"server/index.js")," file, there is a single change: the HTTP server created by the worker process does not actually listen to a given port, the requests will be handled by the master process and then forwarded to the right worker."),(0,a.kt)("p",null,"Before:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"httpServer.listen(PORT, () =>\n  console.log(`server listening at http://localhost:${PORT}`)\n);\n")),(0,a.kt)("p",null,"After:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"setupWorker(io);\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"setupWorker")," method provided by the ",(0,a.kt)("inlineCode",{parentName:"p"},"@socket.io/sticky")," will take care of the synchronization between the master and the worker."),(0,a.kt)("h3",{id:"sessions--messages"},"Sessions & messages"),(0,a.kt)("p",null,"Now that sticky-session is enabled, we need to share sessions and messages across the Socket.IO servers."),(0,a.kt)("p",null,"We create a new SessionStore based on Redis. We will store each session in a Redis hash, with the ",(0,a.kt)("a",{parentName:"p",href:"https://redis.io/commands/hset"},"HSET")," command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'class RedisSessionStore extends SessionStore {\n  // ...\n  saveSession(id, { userID, username, connected }) {\n    this.redisClient\n      .multi()\n      .hset(`session:${id}`, "userID", userID, "username", username, "connected", connected)\n      .expire(`session:${id}`, SESSION_TTL)\n      .exec();\n  }\n  // ...\n}\n')),(0,a.kt)("p",null,"We also set an expiry to the key in order to clean up old sessions."),(0,a.kt)("p",null,"Fetching the session is quite straightforward, with the ",(0,a.kt)("a",{parentName:"p",href:"https://redis.io/commands/hmget"},"HMGET")," command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const mapSession = ([userID, username, connected]) =>\n  userID ? { userID, username, connected: connected === "true" } : undefined;\n\nclass RedisSessionStore extends SessionStore {\n  // ...\n  findSession(id) {\n    return this.redisClient\n      .hmget(`session:${id}`, "userID", "username", "connected")\n      .then(mapSession);\n  }\n  // ...\n}\n')),(0,a.kt)("p",null,"Fetching all sessions is a bit more complex:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'class RedisSessionStore extends SessionStore {\n  // ...\n  async findAllSessions() {\n    // first, we fetch all the keys with the SCAN command\n    const keys = new Set();\n    let nextIndex = 0;\n    do {\n      const [nextIndexAsStr, results] = await this.redisClient.scan(\n        nextIndex,\n        "MATCH",\n        "session:*",\n        "COUNT",\n        "100"\n      );\n      nextIndex = parseInt(nextIndexAsStr, 10);\n      results.forEach((s) => keys.add(s));\n    } while (nextIndex !== 0);\n\n    // and then we retrieve the session details with multiple HMGET commands\n    const commands = [];\n    keys.forEach((key) => {\n      commands.push(["hmget", key, "userID", "username", "connected"]);\n    });\n    return this.redisClient\n      .multi(commands)\n      .exec()\n      .then((results) => {\n        return results\n          .map(([err, session]) => (err ? undefined : mapSession(session)))\n          .filter((v) => !!v);\n      });\n  }\n}\n')),(0,a.kt)("p",null,"Similarly, we create a new MessageStore based on Redis. We will store all the messages linked to a given user in a Redis list, with the ",(0,a.kt)("a",{parentName:"p",href:"https://redis.io/commands/rpush"},"RPUSH")," command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class RedisMessageStore extends MessageStore {\n  // ...\n  saveMessage(message) {\n    const value = JSON.stringify(message);\n    this.redisClient\n      .multi()\n      .rpush(`messages:${message.from}`, value)\n      .rpush(`messages:${message.to}`, value)\n      .expire(`messages:${message.from}`, CONVERSATION_TTL)\n      .expire(`messages:${message.to}`, CONVERSATION_TTL)\n      .exec();\n  }\n  // ...\n}\n")),(0,a.kt)("p",null,"Retrieving the messages is done with the ",(0,a.kt)("a",{parentName:"p",href:"https://redis.io/commands/lrange"},"LRANGE")," command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class RedisMessageStore extends MessageStore {\n  // ...\n  findMessagesForUser(userID) {\n    return this.redisClient\n      .lrange(`messages:${userID}`, 0, -1)\n      .then((results) => {\n        return results.map((result) => JSON.parse(result));\n      });\n  }\n}\n")),(0,a.kt)("h3",{id:"forwarding-messages"},"Forwarding messages"),(0,a.kt)("p",null,"There is one last modification that is needed: we need to make sure that messages actually reach the recipient, even if this recipient is not connected on the same Socket.IO server:"),(0,a.kt)("img",{src:"/images/private-messaging-part-4-redis-adapter.png",alt:"Broadcasting with the Redis adapter"}),(0,a.kt)("p",null,"This is the duty of the Redis adapter, which relies on the Redis pub/sub mechanism to broadcast messages between the Socket.IO servers and eventually reach all clients."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const httpServer = require("http").createServer();\nconst Redis = require("ioredis");\nconst redisClient = new Redis();\nconst io = require("socket.io")(httpServer, {\n  cors: {\n    origin: "http://localhost:8080",\n  },\n  adapter: require("socket.io-redis")({\n    pubClient: redisClient,\n    subClient: redisClient.duplicate(),\n  }),\n});\n')),(0,a.kt)("p",null,"And that's it! If you have a Redis CLI on your machine, you can check the messages that are sent on the wire:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'$ redis-cli\n127.0.0.1:6379> PSUBSCRIBE socket.io*\nReading messages... (press Ctrl-C to quit)\n1) "psubscribe"\n2) "socket.io*"\n3) (integer) 1\n1) "pmessage"\n2) "socket.io*"\n3) "socket.io#/#"\n4) "\\x93\\xa6XFD3OF\\x83..."\n')),(0,a.kt)("p",null,"Documentation:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://redis.io/topics/pubsub"},"Redis pub/sub mechanism")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/v4/using-multiple-nodes/#Passing-events-between-nodes"},"the Redis adapter"))),(0,a.kt)("p",null,"Note: with the Redis adapter, the ",(0,a.kt)("inlineCode",{parentName:"p"},"allSockets()"),' method which is used in the "disconnect" handler automatically returns the Socket IDs across all Socket.IO servers, so there is nothing to update.'),(0,a.kt)("h2",{id:"review"},"Review"),(0,a.kt)("p",null,"OK, so let's sum it up: we have created a fully functional chat (yes, once again!), robust, ready to scale horizontally, which allowed us to introduce some useful Socket.IO features:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/v4/middlewares/"},"middlewares")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/v4/rooms/"},"rooms")),(0,a.kt)("li",{parentName:"ul"},"scaling to ",(0,a.kt)("a",{parentName:"li",href:"/docs/v4/using-multiple-nodes/"},"multiple Socket.IO servers"))),(0,a.kt)("p",null,"Thanks for reading!"))}d.isMDXComponent=!0}}]);