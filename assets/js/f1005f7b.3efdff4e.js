"use strict";(self.webpackChunknimbly=self.webpackChunknimbly||[]).push([[4194],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return g}});var r=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=c(n),g=s,h=m["".concat(l,".").concat(g)]||m[g]||u[g]||a;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function g(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,i=new Array(a);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8274:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return p}});var r=n(7462),s=n(3366),a=(n(7294),n(3905)),i=["components"],o={title:"Private messaging - Part III"},l="Private messaging - Part III",c={type:"mdx",permalink:"/get-started/private-messaging-part-3",source:"@site/src/pages/get-started/private-messaging-part-3.md",title:"Private messaging - Part III",description:"This guide has four distinct parts:",frontMatter:{title:"Private messaging - Part III"}},p=[{value:"Installation",id:"installation",children:[],level:2},{value:"How it works",id:"how-it-works",children:[{value:"Persistent messages",id:"persistent-messages",children:[],level:3}],level:2},{value:"Review",id:"review",children:[],level:2}],u={toc:p};function m(e){var t=e.components,n=(0,s.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"private-messaging---part-iii"},"Private messaging - Part III"),(0,a.kt)("p",null,"This guide has four distinct parts:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/get-started/private-messaging-part-1/"},"Part I"),": initial implementation"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/get-started/private-messaging-part-2/"},"Part II")," : persistent user ID"),(0,a.kt)("li",{parentName:"ul"},"Part III ",(0,a.kt)("strong",{parentName:"li"},"(current)"),": persistent messages"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/get-started/private-messaging-part-4/"},"Part IV"),": scaling up")),(0,a.kt)("p",null,"Here's where we were at the end of the ",(0,a.kt)("a",{parentName:"p",href:"/get-started/private-messaging-part-2/"},"2nd part"),":"),(0,a.kt)("img",{src:"/images/private-messaging-part-2-chat.gif",alt:"Chat (v2)"}),(0,a.kt)("p",null,"All is working pretty well, but there is a last issue which is quite annoying:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"when the sender gets disconnected, all the packets it sends are ",(0,a.kt)("a",{parentName:"li",href:"/docs/v4/client-offline-behavior/#Buffered-events"},"buffered")," until reconnection (which is great in this case)")),(0,a.kt)("img",{src:"/images/private-messaging-part-2-sender-offline.gif",alt:"Chat with sender that gets disconnected"}),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"but when the recipient gets disconnected, the packets are lost, since there is no listening Socket instance in the given room")),(0,a.kt)("img",{src:"/images/private-messaging-part-2-recipient-offline.gif",alt:"Chat with recipient that gets disconnected"}),(0,a.kt)("p",null,"There are multiple solutions to this problem, and we will go for the easiest to implement: store all the messages on the server-side."),(0,a.kt)("p",null,"Note: this 3rd part will be brief, but it underlines an important property of Socket.IO: you cannot rely on the status of the connection. It should be up most of the time but there is a myriad of things that can kill a TCP connection (this is particularly true on mobile browsers)."),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"Let's checkout the branch for part III:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"git checkout examples/private-messaging-part-3\n")),(0,a.kt)("p",null,"Here's what you should see in the current directory:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\u251c\u2500\u2500 babel.config.js\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 public\n\u2502   \u251c\u2500\u2500 favicon.ico\n\u2502   \u251c\u2500\u2500 fonts\n\u2502   \u2502   \u2514\u2500\u2500 Lato-Regular.ttf\n\u2502   \u2514\u2500\u2500 index.html\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 server\n\u2502   \u251c\u2500\u2500 index.js (updated)\n\u2502   \u251c\u2500\u2500 messageStore.js (created)\n\u2502   \u251c\u2500\u2500 package.json\n\u2502   \u2514\u2500\u2500 sessionStore.js\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 App.vue\n    \u251c\u2500\u2500 components\n    \u2502   \u251c\u2500\u2500 Chat.vue (updated)\n    \u2502   \u251c\u2500\u2500 MessagePanel.vue\n    \u2502   \u251c\u2500\u2500 SelectUsername.vue\n    \u2502   \u251c\u2500\u2500 StatusIcon.vue\n    \u2502   \u2514\u2500\u2500 User.vue\n    \u251c\u2500\u2500 main.js\n    \u2514\u2500\u2500 socket.js\n")),(0,a.kt)("p",null,"The complete diff can be found ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/socketio/socket.io/compare/examples/private-messaging-part-2...examples/private-messaging-part-3"},"here"),"."),(0,a.kt)("h2",{id:"how-it-works"},"How it works"),(0,a.kt)("h3",{id:"persistent-messages"},"Persistent messages"),(0,a.kt)("p",null,"On the server-side (",(0,a.kt)("inlineCode",{parentName:"p"},"server/index.js"),"), we now persist the message in our new store:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'io.on("connection", (socket) => {\n  // ...\n  socket.on("private message", ({ content, to }) => {\n    const message = {\n      content,\n      from: socket.userID,\n      to,\n    };\n    socket.to(to).to(socket.userID).emit("private message", message);\n    messageStore.saveMessage(message);\n  });\n  // ...\n});\n')),(0,a.kt)("p",null,"And we fetch the list of messages upon connection:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'io.on("connection", (socket) => {\n  // ...\n  const users = [];\n  const messagesPerUser = new Map();\n  messageStore.findMessagesForUser(socket.userID).forEach((message) => {\n    const { from, to } = message;\n    const otherUser = socket.userID === from ? to : from;\n    if (messagesPerUser.has(otherUser)) {\n      messagesPerUser.get(otherUser).push(message);\n    } else {\n      messagesPerUser.set(otherUser, [message]);\n    }\n  });\n  sessionStore.findAllSessions().forEach((session) => {\n    users.push({\n      userID: session.userID,\n      username: session.username,\n      connected: session.connected,\n      messages: messagesPerUser.get(session.userID) || [],\n    });\n  });\n  socket.emit("users", users);\n  // ...\n});\n')),(0,a.kt)("p",null,"The code is quite straightforward. We shouldn't lose messages upon disconnection anymore:"),(0,a.kt)("img",{src:"/images/private-messaging-part-3-chat.gif",alt:"Chat (v3)"}),(0,a.kt)("h2",{id:"review"},"Review"),(0,a.kt)("p",null,"Now that we have a functional chat, we will see in the ",(0,a.kt)("a",{parentName:"p",href:"/get-started/private-messaging-part-4/"},"4th part")," of this guide how to scale to multiple Socket.IO servers."),(0,a.kt)("p",null,"Thanks for reading!"))}m.isMDXComponent=!0}}]);