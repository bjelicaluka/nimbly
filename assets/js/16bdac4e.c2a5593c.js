"use strict";(self.webpackChunknimbly=self.webpackChunknimbly||[]).push([[7256],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),k=c(n),d=r,m=k["".concat(l,".").concat(d)]||k[d]||u[d]||i;return n?a.createElement(m,s(s({ref:t},p),{},{components:n})):a.createElement(m,s({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=k;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},5535:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return l},default:function(){return k},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return p}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),s=["components"],o={title:"Private messaging - Part I"},l="Private messaging - Part I",c={type:"mdx",permalink:"/get-started/private-messaging-part-1",source:"@site/src/pages/get-started/private-messaging-part-1.md",title:"Private messaging - Part I",description:"In this guide we will create the following application:",frontMatter:{title:"Private messaging - Part I"}},p=[{value:"Installation",id:"installation",children:[],level:2},{value:"Running the frontend",id:"running-the-frontend",children:[],level:2},{value:"Running the server",id:"running-the-server",children:[],level:2},{value:"How it works",id:"how-it-works",children:[{value:"Server initialization",id:"server-initialization",children:[],level:3},{value:"Client initialization",id:"client-initialization",children:[],level:3},{value:"Selection of the username",id:"selection-of-the-username",children:[],level:3},{value:"Listing all users",id:"listing-all-users",children:[],level:3},{value:"Private messaging",id:"private-messaging",children:[],level:3},{value:"Connection status",id:"connection-status",children:[],level:3}],level:2},{value:"Review",id:"review",children:[],level:2}],u={toc:p};function k(e){var t=e.components,o=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"private-messaging---part-i"},"Private messaging - Part I"),(0,i.kt)("p",null,"In this guide we will create the following application:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Chat",src:n(8120).Z,width:"815",height:"763"})),(0,i.kt)("p",null,"We will cover the following topics:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/v4/middlewares/"},"middlewares")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/v4/rooms/"},"rooms")),(0,i.kt)("li",{parentName:"ul"},"scaling to ",(0,i.kt)("a",{parentName:"li",href:"/docs/v4/using-multiple-nodes/"},"multiple Socket.IO servers"))),(0,i.kt)("p",null,"Prerequisites:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"basic knowledge of Socket.IO"),(0,i.kt)("li",{parentName:"ul"},"basic knowledge of ",(0,i.kt)("a",{parentName:"li",href:"https://vuejs.org/v2/guide/"},"Vue.js")," (though knowledge of another popular frontend framework should work too)"),(0,i.kt)("li",{parentName:"ul"},"basic knowledge of ",(0,i.kt)("a",{parentName:"li",href:"https://redis.io/"},"Redis")," (for the final part)")),(0,i.kt)("p",null,"This guide has four distinct parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Part I ",(0,i.kt)("strong",{parentName:"li"},"(current)"),": initial implementation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/get-started/private-messaging-part-2/"},"Part II"),": persistent user ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/get-started/private-messaging-part-3/"},"Part III"),": persistent messages"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/get-started/private-messaging-part-4/"},"Part IV"),": scaling up")),(0,i.kt)("p",null,"Let's start!"),(0,i.kt)("h2",{id:"installation"},"Installation"),(0,i.kt)("p",null,"First, let's retrieve the initial implementation of our chat application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"git clone https://github.com/socketio/socket.io.git\ncd socket.io/examples/private-messaging\ngit checkout examples/private-messaging-part-1\n")),(0,i.kt)("p",null,"Here's what you should see in the current directory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\u251c\u2500\u2500 babel.config.js\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 public\n\u2502   \u251c\u2500\u2500 favicon.ico\n\u2502   \u251c\u2500\u2500 fonts\n\u2502   \u2502   \u2514\u2500\u2500 Lato-Regular.ttf\n\u2502   \u2514\u2500\u2500 index.html\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 server\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 App.vue\n    \u251c\u2500\u2500 components\n    \u2502   \u251c\u2500\u2500 Chat.vue\n    \u2502   \u251c\u2500\u2500 MessagePanel.vue\n    \u2502   \u251c\u2500\u2500 SelectUsername.vue\n    \u2502   \u251c\u2500\u2500 StatusIcon.vue\n    \u2502   \u2514\u2500\u2500 User.vue\n    \u251c\u2500\u2500 main.js\n    \u2514\u2500\u2500 socket.js\n")),(0,i.kt)("p",null,"The code for the frontend is located in the ",(0,i.kt)("inlineCode",{parentName:"p"},"src")," directory, while the code for the server is in the ",(0,i.kt)("inlineCode",{parentName:"p"},"server")," directory."),(0,i.kt)("h2",{id:"running-the-frontend"},"Running the frontend"),(0,i.kt)("p",null,"The project is a basic Vue.js application which was created with ",(0,i.kt)("inlineCode",{parentName:"p"},"@vue/cli"),"."),(0,i.kt)("p",null,"To run it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"npm install\nnpm run serve\n")),(0,i.kt)("p",null,"Then if you open http://localhost:8080 in your browser, you should see:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Username selection",src:n(6122).Z,width:"827",height:"776"})),(0,i.kt)("h2",{id:"running-the-server"},"Running the server"),(0,i.kt)("p",null,"Now, let's start the server:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"cd server\nnpm install\nnpm start\n")),(0,i.kt)("p",null,"Your console should print:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"server listening at http://localhost:3000\n")),(0,i.kt)("p",null,"So far, so good! You should be able to open several tabs and send a few messages between them:"),(0,i.kt)("img",{src:"/images/private-messaging-part-1-chat.gif",alt:"Chat"}),(0,i.kt)("h2",{id:"how-it-works"},"How it works"),(0,i.kt)("h3",{id:"server-initialization"},"Server initialization"),(0,i.kt)("p",null,"The Socket.IO server is initialized in the ",(0,i.kt)("inlineCode",{parentName:"p"},"server/index.js")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const httpServer = require("http").createServer();\nconst io = require("socket.io")(httpServer, {\n  cors: {\n    origin: "http://localhost:8080",\n  },\n});\n')),(0,i.kt)("p",null,"Here, we create a Socket.IO server and attach it to a Node.js HTTP server."),(0,i.kt)("p",null,"Documentation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://nodejs.org/docs/latest/api/http.html"},"Node.js documentation")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/v4/server-initialization/"},"Socket.IO server initialization"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"cors")," configuration is needed so that HTTP requests sent by the frontend (running at ",(0,i.kt)("inlineCode",{parentName:"p"},"http://localhost:8080"),") are allowed to reach the server (running at ",(0,i.kt)("inlineCode",{parentName:"p"},"http://localhost:3000"),", so we are in a cross-origin situation)."),(0,i.kt)("p",null,"Documentation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"},"Cross-Origin Resource Sharing")," (CORS)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/v4/handling-cors/"},"Socket.IO CORS configuration"))),(0,i.kt)("h3",{id:"client-initialization"},"Client initialization"),(0,i.kt)("p",null,"The Socket.IO client is initialized in the ",(0,i.kt)("inlineCode",{parentName:"p"},"src/socket.js")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'import { io } from "socket.io-client";\n\nconst URL = "http://localhost:3000";\nconst socket = io(URL, { autoConnect: false });\n\nexport default socket;\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"autoConnect")," is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," so the connection is not established right away. We will manually call ",(0,i.kt)("a",{parentName:"p",href:"/docs/v4/client-api/#socket-connect"},(0,i.kt)("inlineCode",{parentName:"a"},"socket.connect()"))," later, once the user has selected a username."),(0,i.kt)("p",null,"Documentation: ",(0,i.kt)("a",{parentName:"p",href:"/docs/v4/client-initialization/"},"Socket.IO client initialization")),(0,i.kt)("p",null,"We also register a ",(0,i.kt)("a",{parentName:"p",href:"/docs/v4/listening-to-events/#Catch-all-listeners"},"catch-all listener"),", which is very useful during development:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"socket.onAny((event, ...args) => {\n  console.log(event, args);\n});\n")),(0,i.kt)("p",null,"So that any event received by the client will be printed in the console."),(0,i.kt)("h3",{id:"selection-of-the-username"},"Selection of the username"),(0,i.kt)("p",null,"Now, let's move to ",(0,i.kt)("inlineCode",{parentName:"p"},"src/App.vue"),":"),(0,i.kt)("p",null,"The application is started with ",(0,i.kt)("inlineCode",{parentName:"p"},"usernameAlreadySelected")," set to ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", so the form to select a username is displayed:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Username selection",src:n(6122).Z,width:"827",height:"776"})),(0,i.kt)("p",null,"Once the form is submitted, we'll reach the ",(0,i.kt)("inlineCode",{parentName:"p"},"onUsernameSelection")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"onUsernameSelection(username) {\n  this.usernameAlreadySelected = true;\n  socket.auth = { username };\n  socket.connect();\n}\n")),(0,i.kt)("p",null,"We attach the ",(0,i.kt)("inlineCode",{parentName:"p"},"username")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"auth")," object, and then call ",(0,i.kt)("inlineCode",{parentName:"p"},"socket.connect()"),"."),(0,i.kt)("p",null,"If you open your network tab in your developer tools, you should see a few HTTP requests:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Network monitor upon success",src:n(2899).Z,width:"585",height:"216"})),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"the Engine.IO handshake (contains the session ID \u2014 here, ",(0,i.kt)("inlineCode",{parentName:"li"},"zBjrh...AAAK")," \u2014 that is used in subsequent requests)"),(0,i.kt)("li",{parentName:"ol"},"the Socket.IO handshake request (contains the value of the ",(0,i.kt)("inlineCode",{parentName:"li"},"auth")," option)"),(0,i.kt)("li",{parentName:"ol"},"the Socket.IO handshake response (contains the ",(0,i.kt)("a",{parentName:"li",href:"/docs/v4/server-socket-instance/#Socket-id"},"Socket#id"),")"),(0,i.kt)("li",{parentName:"ol"},"the WebSocket connection"),(0,i.kt)("li",{parentName:"ol"},"the first HTTP long-polling request, which is closed once the WebSocket connection is established")),(0,i.kt)("p",null,"If you see this, it means that the connection was successfully established."),(0,i.kt)("p",null,"On the server-side, we register a middleware which checks the username and allows the connection:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'io.use((socket, next) => {\n  const username = socket.handshake.auth.username;\n  if (!username) {\n    return next(new Error("invalid username"));\n  }\n  socket.username = username;\n  next();\n});\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"username")," is added as an attribute of the ",(0,i.kt)("inlineCode",{parentName:"p"},"socket")," object, in order to be reused later. You can attach any attribute, as long as you don't overwrite an existing one like ",(0,i.kt)("a",{parentName:"p",href:"/docs/v4/server-socket-instance/#Socket-id"},(0,i.kt)("inlineCode",{parentName:"a"},"socket.id"))," or ",(0,i.kt)("a",{parentName:"p",href:"/docs/v4/server-socket-instance/#Socket-handshake"},(0,i.kt)("inlineCode",{parentName:"a"},"socket.handshake")),"."),(0,i.kt)("p",null,"Documentation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/v4/middlewares/"},"middlewares")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/v4/server-socket-instance/"},"the Socket instance"))),(0,i.kt)("p",null,"On the client-side (",(0,i.kt)("inlineCode",{parentName:"p"},"src/App.vue"),"), we add a handler for the ",(0,i.kt)("inlineCode",{parentName:"p"},"connect_error")," event:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'socket.on("connect_error", (err) => {\n  if (err.message === "invalid username") {\n    this.usernameAlreadySelected = false;\n  }\n});\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"connect_error")," event will be emitted upon connection failure:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"due to the low-level errors (when the server is down for example)"),(0,i.kt)("li",{parentName:"ul"},"due to middleware errors")),(0,i.kt)("p",null,"Please note that, in the function above, the low-level errors are not handled (the user could be notified of the connection failure, for example)."),(0,i.kt)("p",null,"Last note: the handler for the ",(0,i.kt)("inlineCode",{parentName:"p"},"connect_error")," is removed in the ",(0,i.kt)("a",{parentName:"p",href:"https://vuejs.org/v2/api/#destroyed"},"destroyed")," hook:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'destroyed() {\n  socket.off("connect_error");\n}\n')),(0,i.kt)("p",null,"So the listeners registered by our ",(0,i.kt)("inlineCode",{parentName:"p"},"App")," component are cleaned up when the component is destroyed."),(0,i.kt)("h3",{id:"listing-all-users"},"Listing all users"),(0,i.kt)("p",null,"Upon connection, we send all existing users to the client:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'io.on("connection", (socket) => {\n  const users = [];\n  for (let [id, socket] of io.of("/").sockets) {\n    users.push({\n      userID: id,\n      username: socket.username,\n    });\n  }\n  socket.emit("users", users);\n  // ...\n});\n')),(0,i.kt)("p",null,"We are looping over the ",(0,i.kt)("inlineCode",{parentName:"p"},'io.of("/").sockets')," object, which is a Map of all currently connected Socket instances, indexed by ",(0,i.kt)("a",{parentName:"p",href:"/docs/v4/server-socket-instance/#Socket-id"},"ID"),"."),(0,i.kt)("p",null,"Two remarks here:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"we are using the ",(0,i.kt)("inlineCode",{parentName:"li"},"socket.id")," as the user ID of our application"),(0,i.kt)("li",{parentName:"ul"},"we are only retrieving the users of the current Socket.IO server (not suitable when scaling up)")),(0,i.kt)("p",null,"We'll come back to this later."),(0,i.kt)("p",null,"On the client-side (",(0,i.kt)("inlineCode",{parentName:"p"},"src/components/Chat.vue"),"), we register a handler for the ",(0,i.kt)("inlineCode",{parentName:"p"},"users")," event:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'socket.on("users", (users) => {\n  users.forEach((user) => {\n    user.self = user.userID === socket.id;\n    initReactiveProperties(user);\n  });\n  // put the current user first, and then sort by username\n  this.users = users.sort((a, b) => {\n    if (a.self) return -1;\n    if (b.self) return 1;\n    if (a.username < b.username) return -1;\n    return a.username > b.username ? 1 : 0;\n  });\n});\n')),(0,i.kt)("p",null,"We also notify the existing users:"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Server")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'io.on("connection", (socket) => {\n  // notify existing users\n  socket.broadcast.emit("user connected", {\n    userID: socket.id,\n    username: socket.username,\n  });\n});\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'socket.broadcast.emit("user connected", ...)')," will emit to all connected clients, except the ",(0,i.kt)("inlineCode",{parentName:"p"},"socket")," itself."),(0,i.kt)("p",null,"The other form of broadcasting, ",(0,i.kt)("inlineCode",{parentName:"p"},'io.emit("user connected", ...)'),', would have sent the "user connected" event to all connected clients, including the new user.'),(0,i.kt)("p",null,"Documentation: ",(0,i.kt)("a",{parentName:"p",href:"/docs/v4/broadcasting-events/"},"broadcasting events")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Client")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'socket.on("user connected", (user) => {\n  initReactiveProperties(user);\n  this.users.push(user);\n});\n')),(0,i.kt)("p",null,"The list of users is displayed on the left panel:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Users list",src:n(3372).Z,width:"276",height:"467"})),(0,i.kt)("h3",{id:"private-messaging"},"Private messaging"),(0,i.kt)("p",null,"When selecting a given user, the right panel displays a chat window:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Chat",src:n(8120).Z,width:"815",height:"763"})),(0,i.kt)("p",null,"Here is how private messages are implemented:"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Client (sender)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'onMessage(content) {\n  if (this.selectedUser) {\n    socket.emit("private message", {\n      content,\n      to: this.selectedUser.userID,\n    });\n    this.selectedUser.messages.push({\n      content,\n      fromSelf: true,\n    });\n  }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Server")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'socket.on("private message", ({ content, to }) => {\n  socket.to(to).emit("private message", {\n    content,\n    from: socket.id,\n  });\n});\n')),(0,i.kt)("p",null,"Here, we are using the concept of ",(0,i.kt)("a",{parentName:"p",href:"/docs/v4/rooms/"},"Rooms"),". These are channels that Socket instances can join and leave, and you can broadcast to all clients in a room."),(0,i.kt)("p",null,"We are relying on the fact that the Socket instance automatically joins the room identified by its id (",(0,i.kt)("inlineCode",{parentName:"p"},"socket.join(socket.id)")," is called for you)."),(0,i.kt)("p",null,"So ",(0,i.kt)("inlineCode",{parentName:"p"},'socket.to(to).emit("private message", ...)')," emits to the given user ID."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Client (recipient)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'socket.on("private message", ({ content, from }) => {\n  for (let i = 0; i < this.users.length; i++) {\n    const user = this.users[i];\n    if (user.userID === from) {\n      user.messages.push({\n        content,\n        fromSelf: false,\n      });\n      if (user !== this.selectedUser) {\n        user.hasNewMessages = true;\n      }\n      break;\n    }\n  }\n});\n')),(0,i.kt)("h3",{id:"connection-status"},"Connection status"),(0,i.kt)("p",null,"On the client-side, the Socket instance emits two special events:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"connect"),": upon connection or reconnection"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"disconnect"),": upon disconnection")),(0,i.kt)("p",null,"Those events can be used to track the state of the connection (in ",(0,i.kt)("inlineCode",{parentName:"p"},"src/components/Chat.vue"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'socket.on("connect", () => {\n  this.users.forEach((user) => {\n    if (user.self) {\n      user.connected = true;\n    }\n  });\n});\n\nsocket.on("disconnect", () => {\n  this.users.forEach((user) => {\n    if (user.self) {\n      user.connected = false;\n    }\n  });\n});\n')),(0,i.kt)("p",null,"You can test it by stopping the server:"),(0,i.kt)("img",{src:"/images/private-messaging-part-1-connection-status.gif",alt:"Connection status"}),(0,i.kt)("h2",{id:"review"},"Review"),(0,i.kt)("p",null,"OK, so... what we have for now is great, but there is an obvious issue:"),(0,i.kt)("img",{src:"/images/private-messaging-part-1-duplicate-users.gif",alt:"Duplicate users"}),(0,i.kt)("p",null,"Explanation: a new Socket ID is generated upon reconnection, so every time a user gets disconnected and reconnects, it will get a new user ID."),(0,i.kt)("p",null,"That's why we need a persistent user ID, which is the subject of the ",(0,i.kt)("a",{parentName:"p",href:"/get-started/private-messaging-part-2/"},"2nd part")," of this guide."),(0,i.kt)("p",null,"Thanks for reading!"))}k.isMDXComponent=!0},2899:function(e,t,n){t.Z=n.p+"assets/images/network-monitor-2e47dbe233100aa290595f8687a9fcba.png"},8120:function(e,t,n){t.Z=n.p+"assets/images/private-messaging-part-1-chat-ab610e9e03738ad37f7b0fb55c771087.png"},6122:function(e,t,n){t.Z=n.p+"assets/images/private-messaging-part-1-username-selection-82131cb52abb2dcca4df14340352d191.png"},3372:function(e,t,n){t.Z=n.p+"assets/images/private-messaging-part-1-users-list-7d3f890494b1481065ba4afe0f5569f1.png"}}]);