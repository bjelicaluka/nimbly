[{"title":"Broadcasting events","type":0,"sectionRef":"#","url":"docs/v1/broadcasting-events/","content":"","keywords":""},{"title":"To all connected clients​","type":1,"pageTitle":"Broadcasting events","url":"docs/v1/broadcasting-events/#to-all-connected-clients","content":"  io.emit(&quot;hello&quot;, &quot;world&quot;); Copy caution Clients that are currently disconnected (or in the process of reconnecting) won't receive the event. Storing this event somewhere (in a database, for example) is up to you, depending on your use case. "},{"title":"To all connected clients except the sender​","type":1,"pageTitle":"Broadcasting events","url":"docs/v1/broadcasting-events/#to-all-connected-clients-except-the-sender","content":"  io.on(&quot;connection&quot;, (socket) =&gt; { socket.broadcast.emit(&quot;hello&quot;, &quot;world&quot;); }); Copy note In the example above, using socket.emit(&quot;hello&quot;, &quot;world&quot;) (without broadcast flag) would send the event to &quot;client A&quot;. You can find the list of all the ways to send an event in the cheatsheet. "},{"title":"With multiple Socket.IO servers​","type":1,"pageTitle":"Broadcasting events","url":"docs/v1/broadcasting-events/#with-multiple-socketio-servers","content":"Broadcasting also works with multiple Socket.IO servers. You just need to replace the default adapter by the Redis Adapter or another compatible adapter.   In certain cases, you may want to only broadcast to clients that are connected to the current server. You can achieve this with the local flag: io.local.emit(&quot;hello&quot;, &quot;world&quot;); Copy   In order to target specific clients when broadcasting, please see the documentation about Rooms. "},{"title":"Client Initialization","type":0,"sectionRef":"#","url":"docs/v1/client-initialization/","content":"","keywords":""},{"title":"From the same domain​","type":1,"pageTitle":"Client Initialization","url":"docs/v1/client-initialization/#from-the-same-domain","content":"If your front is served on the same domain as your server, you can simply use: const socket = io(); Copy The server URL will be deduced from the window.location object. "},{"title":"From a different domain​","type":1,"pageTitle":"Client Initialization","url":"docs/v1/client-initialization/#from-a-different-domain","content":"In case your front is not served from the same domain as your server, you have to pass the URL of your server. const socket = io(&quot;https://server-domain.com&quot;); Copy In that case, please make sure to enable Cross-Origin Resource Sharing (CORS) on the server. info You can use either https or wss (respectively, http or ws). // the following forms are similar const socket = io(&quot;https://server-domain.com&quot;); const socket = io(&quot;wss://server-domain.com&quot;); const socket = io(&quot;server-domain.com&quot;); // only in the browser when the page is served over https (will not work in Node.js) Copy "},{"title":"Custom namespace​","type":1,"pageTitle":"Client Initialization","url":"docs/v1/client-initialization/#custom-namespace","content":"In the examples above, the client will connect to the main namespace. Using only the main namespace should be sufficient for most use cases, but you can specify the namespace with: // same origin version const socket = io(&quot;/admin&quot;); // cross origin version const socket = io(&quot;https://server-domain.com/admin&quot;); Copy You can find more details about namespaces here. "},{"title":"Options​","type":1,"pageTitle":"Client Initialization","url":"docs/v1/client-initialization/#options","content":"The complete list of available options can be found here. "},{"title":"Offline behavior","type":0,"sectionRef":"#","url":"docs/v1/client-offline-behavior/","content":"","keywords":""},{"title":"Buffered events​","type":1,"pageTitle":"Offline behavior","url":"docs/v1/client-offline-behavior/#buffered-events","content":"By default, any event emitted while the Socket is not connected will be buffered until reconnection. While useful in most cases (when the reconnection delay is short), it could result in a huge spike of events when the connection is restored. There are several solutions to prevent this behavior, depending on your use case: use the connected attribute of the Socket instance if (socket.connected) { socket.emit( /* ... */ ); } else { // ... } Copy use volatile events socket.volatile.emit( /* ... */ ); Copy "},{"title":"Client Installation","type":0,"sectionRef":"#","url":"docs/v1/client-installation/","content":"","keywords":""},{"title":"Version compatibility​","type":1,"pageTitle":"Client Installation","url":"docs/v1/client-installation/#version-compatibility","content":"Here is the compatibility table between the server and the JS client: JS Client version\tSocket.IO server version 1.x\t2.x\t3.x\t4.x 1.x\tYES\tNO\tNO\tNO 2.x\tNO\tYES\tYES1\tYES1 3.x\tNO\tNO\tYES\tYES 4.x\tNO\tNO\tYES\tYES [1] Yes, with allowEIO3: true Please check the associated migration guides: v2 to v3v3 to v4 "},{"title":"Browser support​","type":1,"pageTitle":"Client Installation","url":"docs/v1/client-installation/#browser-support","content":"Socket.IO does support IE9 and above. IE 6/7/8 are not supported anymore. Browser compatibility is tested thanks to the awesome Sauce Labs platform:  "},{"title":"Latest releases​","type":1,"pageTitle":"Client Installation","url":"docs/v1/client-installation/#latest-releases","content":"4.5.0 (2022/04/23): GitHub release / diff / npm4.4.1 (2022/01/06): GitHub release / diff / npm4.4.0 (2021/11/18): GitHub release / diff / npm4.3.2 (2021/11/08): GitHub release / diff / npm4.3.1 (2021/10/17): GitHub release / diff / npm4.3.0 (2021/10/15): GitHub release / diff / npm4.2.0 (2021/08/30): GitHub release / diff / npm "},{"title":"Installation​","type":1,"pageTitle":"Client Installation","url":"docs/v1/client-installation/#installation","content":""},{"title":"Standalone build​","type":1,"pageTitle":"Client Installation","url":"docs/v1/client-installation/#standalone-build","content":"By default, the Socket.IO server exposes a client bundle at /socket.io/socket.io.js. io will be registered as a global variable: &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const socket = io(); &lt;/script&gt; Copy If you don't need this (see other options below), you can disable the functionality on the server side: const { Server } = require(&quot;socket.io&quot;); const io = new Server({ serveClient: false }); Copy "},{"title":"From a CDN​","type":1,"pageTitle":"Client Installation","url":"docs/v1/client-installation/#from-a-cdn","content":"You can also include the client bundle from a CDN: &lt;script src=&quot;https://cdn.socket.io/4.5.0/socket.io.min.js&quot; integrity=&quot;sha384-7EyYLQZgWBi67fBtVxw60/OWl1kjsfrPFcaU0pp0nAh+i8FD068QogUvg85Ewy1k&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; Copy Socket.IO is also available from other CDN: cdnjs: https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.0/socket.io.min.jsjsDelivr: https://cdn.jsdelivr.net/npm/socket.io-client@4.5.0/dist/socket.io.min.jsunpkg: https://unpkg.com/socket.io-client@4.5.0/dist/socket.io.min.js There are several bundles available: Name\tSize\tDescriptionsocket.io.js\t34.7 kB gzip\tUnminified version, with debug socket.io.min.js\t14.7 kB min+gzip\tProduction version, without debug socket.io.msgpack.min.js\t15.3 kB min+gzip\tProduction version, without debug and with the msgpack parser The debug package allows to print debug information to the console. You can find more information here. During development, we recommend using the socket.io.js bundle. By setting localStorage.debug = 'socket.io-client:socket', any event received by the client will be printed to the console. For production, please use the socket.io.min.js bundle, which is an optimized build excluding the debug package. "},{"title":"From NPM​","type":1,"pageTitle":"Client Installation","url":"docs/v1/client-installation/#from-npm","content":"The Socket.IO client is compatible with bundlers like webpack or browserify. NPMYarnpnpm npm install socket.io-client Copy The client can also be run from Node.js. Note: for the reasons cited above, you may want to exclude debug from your browser bundle. With webpack, you can use webpack-remove-debug. Note for TypeScript users: the types are now included in the socket.io-client package and thus the types from @types/socket.io-client are not needed anymore and may in fact cause errors: Object literal may only specify known properties, and 'extraHeaders' does not exist in type 'ConnectOpts' Copy "},{"title":"Miscellaneous​","type":1,"pageTitle":"Client Installation","url":"docs/v1/client-installation/#miscellaneous","content":""},{"title":"Dependency tree​","type":1,"pageTitle":"Client Installation","url":"docs/v1/client-installation/#dependency-tree","content":"A basic installation of the client includes 10 packages: └─┬ socket.io-client@4.5.0 ├── @socket.io/component-emitter@3.1.0 ├─┬ debug@4.3.4 │ └── ms@2.1.2 ├─┬ engine.io-client@6.2.1 │ ├── @socket.io/component-emitter@3.1.0 deduped │ ├── debug@4.3.4 deduped │ ├─┬ engine.io-parser@5.0.3 │ │ └── @socket.io/base64-arraybuffer@1.0.2 │ ├─┬ ws@8.2.3 │ │ ├── UNMET OPTIONAL DEPENDENCY bufferutil@^4.0.1 │ │ └── UNMET OPTIONAL DEPENDENCY utf-8-validate@^5.0.2 │ └── xmlhttprequest-ssl@2.0.0 └─┬ socket.io-parser@4.2.0 ├── @socket.io/component-emitter@3.1.0 deduped └── debug@4.3.4 deduped Copy "},{"title":"Transitive versions​","type":1,"pageTitle":"Client Installation","url":"docs/v1/client-installation/#transitive-versions","content":"The engine.io-client package brings the engine that is responsible for managing the low-level connections (HTTP long-polling or WebSocket). See also: How it works socket.io-client version\tengine.io-client version\tws version14.5.x\t6.2.x\t8.2.x 4.4.x\t6.1.x\t8.2.x 4.3.x\t6.0.x\t8.2.x 4.2.x\t5.2.x\t7.4.x 4.1.x\t5.1.x\t7.4.x 4.0.x\t5.0.x\t7.4.x 3.1.x\t4.1.x\t7.4.x 3.0.x\t4.0.x\t7.4.x 2.4.x\t3.5.x\t7.4.x [1] for Node.js users only. In the browser, the native WebSocket API is used. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/v1/","content":"","keywords":""},{"title":"What Socket.IO is​","type":1,"pageTitle":"Introduction","url":"docs/v1/#what-socketio-is","content":"Socket.IO is a library that enables low-latency, bidirectional and event-based communication between a client and a server.   It is built on top of the WebSocket protocol and provides additional guarantees like fallback to HTTP long-polling or automatic reconnection. info WebSocket is a communication protocol which provides a full-duplex and low-latency channel between the server and the browser. More information can be found here. There are several Socket.IO server implementations available: JavaScript (whose documentation can be found here on this website) Installation stepsAPISource code Java: https://github.com/mrniko/netty-socketioJava: https://github.com/trinopoty/socket.io-server-javaPython: https://github.com/miguelgrinberg/python-socketio And client implementations in most major languages: JavaScript (which can be run either in the browser, in Node.js or in React Native) Installation stepsAPISource code Java: https://github.com/socketio/socket.io-client-javaC++: https://github.com/socketio/socket.io-client-cppSwift: https://github.com/socketio/socket.io-client-swiftDart: https://github.com/rikulo/socket.io-client-dartPython: https://github.com/miguelgrinberg/python-socketio.Net: https://github.com/doghappy/socket.io-client-csharpGolang: https://github.com/googollee/go-socket.ioRust: https://github.com/1c3t3a/rust-socketioKotlin: https://github.com/icerockdev/moko-socket-io Here's a basic example with plain WebSockets: Server (based on ws) import { WebSocketServer } from &quot;ws&quot;; const server = new WebSocketServer({ port: 3000 }); server.on(&quot;connection&quot;, (socket) =&gt; { // send a message to the client socket.send(JSON.stringify({ type: &quot;hello from server&quot;, content: [ 1, &quot;2&quot; ] })); // receive a message from the client socket.on(&quot;message&quot;, (data) =&gt; { const packet = JSON.parse(data); switch (packet.type) { case &quot;hello from client&quot;: // ... break; } }); }); Copy Client const socket = new WebSocket(&quot;ws://localhost:3000&quot;); socket.addEventListener(&quot;open&quot;, () =&gt; { // send a message to the server socket.send(JSON.stringify({ type: &quot;hello from client&quot;, content: [ 3, &quot;4&quot; ] })); }); // receive a message from the server socket.addEventListener(&quot;message&quot;, ({ data }) =&gt; { const packet = JSON.parse(data); switch (packet.type) { case &quot;hello from server&quot;: // ... break; } }); Copy And here's the same example with Socket.IO: Server import { Server } from &quot;socket.io&quot;; const io = new Server(3000); io.on(&quot;connection&quot;, (socket) =&gt; { // send a message to the client socket.emit(&quot;hello from server&quot;, 1, &quot;2&quot;, { 3: Buffer.from([4]) }); // receive a message from the client socket.on(&quot;hello from client&quot;, (...args) =&gt; { // ... }); }); Copy Client import { io } from &quot;socket.io-client&quot;; const socket = io(&quot;ws://localhost:3000&quot;); // send a message to the server socket.emit(&quot;hello from client&quot;, 5, &quot;6&quot;, { 7: Uint8Array.from([8]) }); // receive a message from the server socket.on(&quot;hello from server&quot;, (...args) =&gt; { // ... }); Copy Both examples looks really similar, but under the hood Socket.IO provides additional features that hide the complexity of running an application based on WebSockets in production. Those features are listed below. But first, let's make it clear what Socket.IO is not. "},{"title":"What Socket.IO is not​","type":1,"pageTitle":"Introduction","url":"docs/v1/#what-socketio-is-not","content":"caution Socket.IO is NOT a WebSocket implementation. Although Socket.IO indeed uses WebSocket for transport when possible, it adds additional metadata to each packet. That is why a WebSocket client will not be able to successfully connect to a Socket.IO server, and a Socket.IO client will not be able to connect to a plain WebSocket server either. // WARNING: the client will NOT be able to connect! const socket = io(&quot;ws://echo.websocket.org&quot;); Copy If you are looking for a plain WebSocket server, please take a look at ws or µWebSockets.js. There are also discussions for including a WebSocket server in the Node.js core. On the client-side, you might be interested in the robust-websocket package. caution Socket.IO is not meant to be used in a background service for mobile applications. The Socket.IO library keeps an open TCP connection to the server, which may result in a high battery drain for your users. Please use a dedicated messaging platform like FCM for this use case. "},{"title":"Features​","type":1,"pageTitle":"Introduction","url":"docs/v1/#features","content":"Here are the features provided by Socket.IO over plain WebSockets: "},{"title":"HTTP long-polling fallback​","type":1,"pageTitle":"Introduction","url":"docs/v1/#http-long-polling-fallback","content":"The connection will fall back to HTTP long-polling in case the WebSocket connection cannot be established. This feature was the #1 reason people used Socket.IO when the project was created more than ten years ago (!), as the browser support for WebSockets was still in its infancy. Even if most browsers now support WebSockets (more than 97%), it is still a great feature as we still receive reports from users that cannot establish a WebSocket connection because they are behind some misconfigured proxy. "},{"title":"Automatic reconnection​","type":1,"pageTitle":"Introduction","url":"docs/v1/#automatic-reconnection","content":"Under some particular conditions, the WebSocket connection between the server and the client can be interrupted with both sides being unaware of the broken state of the link. That's why Socket.IO includes a heartbeat mechanism, which periodically checks the status of the connection. And when the client eventually gets disconnected, it automatically reconnects with an exponential back-off delay, in order not to overwhelm the server. "},{"title":"Packet buffering​","type":1,"pageTitle":"Introduction","url":"docs/v1/#packet-buffering","content":"The packets are automatically buffered when the client is disconnected, and will be sent upon reconnection. More information here. "},{"title":"Acknowledgements​","type":1,"pageTitle":"Introduction","url":"docs/v1/#acknowledgements","content":"Socket.IO provides a convenient way to send an event and receive a response: Sender socket.emit(&quot;hello&quot;, &quot;world&quot;, (response) =&gt; { console.log(response); // &quot;got it&quot; }); Copy Receiver socket.on(&quot;hello&quot;, (arg, callback) =&gt; { console.log(arg); // &quot;world&quot; callback(&quot;got it&quot;); }); Copy You can also add a timeout: socket.timeout(5000).emit(&quot;hello&quot;, &quot;world&quot;, (err, response) =&gt; { if (err) { // the other side did not acknowledge the event in the given delay } else { console.log(response); // &quot;got it&quot; } }); Copy "},{"title":"Broadcasting​","type":1,"pageTitle":"Introduction","url":"docs/v1/#broadcasting","content":"On the server-side, you can send an event to all connected clients or to a subset of clients: // to all connected clients io.emit(&quot;hello&quot;); // to all connected clients in the &quot;news&quot; room io.to(&quot;news&quot;).emit(&quot;hello&quot;); Copy This also works when scaling to multiple nodes. "},{"title":"Multiplexing​","type":1,"pageTitle":"Introduction","url":"docs/v1/#multiplexing","content":"Namespaces allow you to split the logic of your application over a single shared connection. This can be useful for example if you want to create an &quot;admin&quot; channel that only authorized users can join. io.on(&quot;connection&quot;, (socket) =&gt; { // classic users }); io.of(&quot;/admin&quot;).on(&quot;connection&quot;, (socket) =&gt; { // admin users }); Copy More on that here. "},{"title":"Common questions​","type":1,"pageTitle":"Introduction","url":"docs/v1/#common-questions","content":""},{"title":"Is Socket.IO still needed today?​","type":1,"pageTitle":"Introduction","url":"docs/v1/#is-socketio-still-needed-today","content":"That's a fair question, since WebSockets are supported almost everywhere now. That being said, we believe that, if you use plain WebSockets for your application, you will eventually need to implement most of the features that are already included (and battle-tested) in Socket.IO, like reconnection, acknowledgements or broadcasting. "},{"title":"What is the overhead of the Socket.IO protocol?​","type":1,"pageTitle":"Introduction","url":"docs/v1/#what-is-the-overhead-of-the-socketio-protocol","content":"socket.emit(&quot;hello&quot;, &quot;world&quot;) will be sent as a single WebSocket frame containing 42[&quot;hello&quot;,&quot;world&quot;] with: 4 being Engine.IO &quot;message&quot; packet type2 being Socket.IO &quot;message&quot; packet type[&quot;hello&quot;,&quot;world&quot;] being the JSON.stringify()-ed version of the arguments array So, a few additional bytes for each message, which can be further reduced by the usage of a custom parser. info The size of the browser bundle itself is 10.4 kB (minified and gzipped). "},{"title":"Something does not work properly, please help?​","type":1,"pageTitle":"Introduction","url":"docs/v1/#something-does-not-work-properly-please-help","content":"Please check the Troubleshooting guide. "},{"title":"Next steps​","type":1,"pageTitle":"Introduction","url":"docs/v1/#next-steps","content":"Get started exampleServer installationClient installation "},{"title":"Client usage with bundlers","type":0,"sectionRef":"#","url":"docs/v1/client-with-bundlers/","content":"","keywords":""},{"title":"Webpack 5​","type":1,"pageTitle":"Client usage with bundlers","url":"docs/v1/client-with-bundlers/#webpack-5","content":"Documentation: https://webpack.js.org/concepts/ "},{"title":"Browser​","type":1,"pageTitle":"Client usage with bundlers","url":"docs/v1/client-with-bundlers/#browser","content":"Installation: npm i -D socket.io-client webpack webpack-cli babel-loader @babel/core @babel/preset-env \\ @babel/plugin-transform-object-assign webpack-remove-debug Copy webpack.config.js module.exports = { entry: &quot;./index.js&quot;, output: { filename: &quot;bundle.js&quot;, }, mode: &quot;production&quot;, node: false, module: { rules: [ { test: /\\.m?js$/, use: { loader: &quot;babel-loader&quot;, options: { presets: [&quot;@babel/preset-env&quot;], // ensure compatibility with older browsers plugins: [&quot;@babel/plugin-transform-object-assign&quot;], // ensure compatibility with IE 11 }, }, }, { test: /\\.js$/, loader: &quot;webpack-remove-debug&quot;, // remove &quot;debug&quot; package }, ], }, }; Copy For reference, here is the output of the webpack-bundle-analyzer package:  "},{"title":"Node.js​","type":1,"pageTitle":"Client usage with bundlers","url":"docs/v1/client-with-bundlers/#nodejs","content":"To use the client in a Node.js environment (server to server connection), here is the configuration: Installation: npm i -D socket.io-client webpack webpack-cli Copy webpack.config.js module.exports = { entry: &quot;./index.js&quot;, output: { filename: &quot;bundle.js&quot;, }, mode: &quot;production&quot;, target: &quot;node&quot;, externals: { bufferutil: &quot;bufferutil&quot;, &quot;utf-8-validate&quot;: &quot;utf-8-validate&quot;, }, }; Copy Note: without setting target: &quot;node&quot;, you will likely encounter the following error: ReferenceError: document is not defined Copy "},{"title":"Rollup.js​","type":1,"pageTitle":"Client usage with bundlers","url":"docs/v1/client-with-bundlers/#rollupjs","content":"Documentation: https://rollupjs.org/guide/en/ "},{"title":"Browser​","type":1,"pageTitle":"Client usage with bundlers","url":"docs/v1/client-with-bundlers/#browser-1","content":"Installation: npm i -D socket.io-client rollup @rollup/plugin-node-resolve @rollup/plugin-commonjs @rollup/plugin-commonjs \\ @rollup/plugin-babel rollup-plugin-uglify babel @babel/core @babel/preset-env Copy rollup.config.js import resolve from &quot;@rollup/plugin-node-resolve&quot;; import commonjs from &quot;@rollup/plugin-commonjs&quot;; import babel from &quot;@rollup/plugin-babel&quot;; import { uglify } from &quot;rollup-plugin-uglify&quot;; export default { input: &quot;index.js&quot;, output: { file: &quot;bundle.js&quot;, format: &quot;cjs&quot;, }, plugins: [ resolve({ browser: true, }), commonjs(), babel({ include: [&quot;**.js&quot;, &quot;node_modules/**&quot;], babelHelpers: &quot;bundled&quot;, presets: [&quot;@babel/preset-env&quot;], }), uglify(), ], }; Copy "},{"title":"Node.js​","type":1,"pageTitle":"Client usage with bundlers","url":"docs/v1/client-with-bundlers/#nodejs-1","content":"Installation: npm i -D socket.io-client rollup @rollup/plugin-node-resolve @rollup/plugin-commonjs rollup-plugin-uglify Copy rollup.config.js import resolve from &quot;@rollup/plugin-node-resolve&quot;; import commonjs from &quot;@rollup/plugin-commonjs&quot;; import { uglify } from &quot;rollup-plugin-uglify&quot;; export default { input: &quot;index.js&quot;, output: { file: &quot;bundle.js&quot;, format: &quot;cjs&quot;, }, plugins: [ resolve({ preferBuiltins: true, }), commonjs(), uglify(), ], }; Copy "},{"title":"Handling CORS","type":0,"sectionRef":"#","url":"docs/v1/handling-cors/","content":"","keywords":""},{"title":"Configuration​","type":1,"pageTitle":"Handling CORS","url":"docs/v1/handling-cors/#configuration","content":"Since Socket.IO v3, you need to explicitly enable Cross-Origin Resource Sharing (CORS). import { createServer } from &quot;http&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer(); const io = new Server(httpServer, { cors: { origin: &quot;https://example.com&quot; } }); Copy All options will be forwarded to the cors package. The complete list of options can be found here. Example with cookies (withCredentials) and additional headers: // server-side const io = new Server(httpServer, { cors: { origin: &quot;https://example.com&quot;, allowedHeaders: [&quot;my-custom-header&quot;], credentials: true } }); // client-side import { io } from &quot;socket.io-client&quot;; const socket = io(&quot;https://api.example.com&quot;, { withCredentials: true, extraHeaders: { &quot;my-custom-header&quot;: &quot;abcd&quot; } }); Copy Note: this also applies to localhost if your web application and your server are not served from the same port const io = new Server(httpServer, { cors: { origin: &quot;http://localhost:8080&quot; } }); httpServer.listen(3000); Copy You can disallow all cross-origin requests with the allowRequest option: const io = new Server(httpServer, { allowRequest: (req, callback) =&gt; { const noOriginHeader = req.headers.origin === undefined; callback(null, noOriginHeader); } }); Copy "},{"title":"Troubleshooting​","type":1,"pageTitle":"Handling CORS","url":"docs/v1/handling-cors/#troubleshooting","content":""},{"title":"CORS header ‘Access-Control-Allow-Origin’ missing​","type":1,"pageTitle":"Handling CORS","url":"docs/v1/handling-cors/#cors-header-access-control-allow-origin-missing","content":"Full error message: Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at .../socket.io/?EIO=4&amp;transport=polling&amp;t=NMnp2WI. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing). If you have properly configured your server (see above), this could mean that your browser wasn't able to reach the Socket.IO server. The following command: curl &quot;https://api.example.com/socket.io/?EIO=4&amp;transport=polling&quot; Copy should return something like: 0{&quot;sid&quot;:&quot;Lbo5JLzTotvW3g2LAAAA&quot;,&quot;upgrades&quot;:[&quot;websocket&quot;],&quot;pingInterval&quot;:25000,&quot;pingTimeout&quot;:20000} Copy If that's not the case, please check that your server is listening and is actually reachable on the given port. "},{"title":"Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*’​","type":1,"pageTitle":"Handling CORS","url":"docs/v1/handling-cors/#credential-is-not-supported-if-the-cors-header-access-control-allow-origin-is-","content":"Full error message: Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at ‘.../socket.io/?EIO=4&amp;transport=polling&amp;t=NvQfU77’. (Reason: Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*’) You can't set withCredentials to true with origin: *, you need to use a specific origin: import { createServer } from &quot;http&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer(); const io = new Server(httpServer, { cors: { origin: &quot;https://my-frontend.com&quot;, // or with an array of origins // origin: [&quot;https://my-frontend.com&quot;, &quot;https://my-other-frontend.com&quot;, &quot;http://localhost:3000&quot;], credentials: true } }); Copy "},{"title":"Expected ‘true’ in CORS header ‘Access-Control-Allow-Credentials’​","type":1,"pageTitle":"Handling CORS","url":"docs/v1/handling-cors/#expected-true-in-cors-header-access-control-allow-credentials","content":"Full error message: Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at .../socket.io/?EIO=4&amp;transport=polling&amp;t=NvQny19. (Reason: expected ‘true’ in CORS header ‘Access-Control-Allow-Credentials’) In that case, withCredentials is set to true on the client, but the server is missing the credentials attribute in the cors option. See the example above. "},{"title":"Emit cheatsheet","type":0,"sectionRef":"#","url":"docs/v1/emit-cheatsheet/","content":"","keywords":""},{"title":"Server-side​","type":1,"pageTitle":"Emit cheatsheet","url":"docs/v1/emit-cheatsheet/#server-side","content":"io.on(&quot;connection&quot;, (socket) =&gt; { // basic emit socket.emit(/* ... */); // to all clients in the current namespace except the sender socket.broadcast.emit(/* ... */); // to all clients in room1 except the sender socket.to(&quot;room1&quot;).emit(/* ... */); // to all clients in room1 and/or room2 except the sender socket.to([&quot;room1&quot;, &quot;room2&quot;]).emit(/* ... */); // to all clients in room1 io.in(&quot;room1&quot;).emit(/* ... */); // to all clients in room1 and/or room2 except those in room3 io.to([&quot;room1&quot;, &quot;room2&quot;]).except(&quot;room3&quot;).emit(/* ... */); // to all clients in namespace &quot;myNamespace&quot; io.of(&quot;myNamespace&quot;).emit(/* ... */); // to all clients in room1 in namespace &quot;myNamespace&quot; io.of(&quot;myNamespace&quot;).to(&quot;room1&quot;).emit(/* ... */); // to individual socketid (private message) io.to(socketId).emit(/* ... */); // to all clients on this node (when using multiple nodes) io.local.emit(/* ... */); // to all connected clients io.emit(/* ... */); // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room // named `socket.id` but the sender. Please use the classic `socket.emit()` instead. // with acknowledgement socket.emit(&quot;question&quot;, (answer) =&gt; { // ... }); // without compression socket.compress(false).emit(/* ... */); // a message that might be dropped if the low-level transport is not writable socket.volatile.emit(/* ... */); // with timeout socket.timeout(5000).emit(&quot;my-event&quot;, (err) =&gt; { if (err) { // the other side did not acknowledge the event in the given delay } }); }); Copy "},{"title":"Client-side​","type":1,"pageTitle":"Emit cheatsheet","url":"docs/v1/emit-cheatsheet/#client-side","content":"// basic emit socket.emit(/* ... */); // with acknowledgement socket.emit(&quot;question&quot;, (answer) =&gt; { // ... }); // without compression socket.compress(false).emit(/* ... */); // a message that might be dropped if the low-level transport is not writable socket.volatile.emit(/* ... */); // with timeout socket.timeout(5000).emit(&quot;my-event&quot;, (err) =&gt; { if (err) { // the other side did not acknowledge the event in the given delay } }); Copy "},{"title":"Reserved events​","type":1,"pageTitle":"Emit cheatsheet","url":"docs/v1/emit-cheatsheet/#reserved-events","content":"On each side, the following events are reserved and should not be used as event names by your application: connectconnect_errordisconnectdisconnectingnewListenerremoveListener // BAD, will throw an error socket.emit(&quot;disconnecting&quot;); Copy "},{"title":"The Socket instance (client-side)","type":0,"sectionRef":"#","url":"docs/v1/client-socket-instance/","content":"","keywords":""},{"title":"Socket#id​","type":1,"pageTitle":"The Socket instance (client-side)","url":"docs/v1/client-socket-instance/#socketid","content":"Each new connection is assigned a random 20-characters identifier. This identifier is synced with the value on the server-side. // server-side io.on(&quot;connection&quot;, (socket) =&gt; { console.log(socket.id); // x8WIv7-mJelg7on_ALbx }); // client-side socket.on(&quot;connect&quot;, () =&gt; { console.log(socket.id); // x8WIv7-mJelg7on_ALbx }); socket.on(&quot;disconnect&quot;, () =&gt; { console.log(socket.id); // undefined }); Copy "},{"title":"Socket#connected​","type":1,"pageTitle":"The Socket instance (client-side)","url":"docs/v1/client-socket-instance/#socketconnected","content":"This attribute describes whether the socket is currently connected to the server. socket.on(&quot;connect&quot;, () =&gt; { console.log(socket.connected); // true }); socket.on(&quot;disconnect&quot;, () =&gt; { console.log(socket.connected); // false }); Copy "},{"title":"Socket#io​","type":1,"pageTitle":"The Socket instance (client-side)","url":"docs/v1/client-socket-instance/#socketio","content":"A reference to the underlying Manager. socket.on(&quot;connect&quot;, () =&gt; { const engine = socket.io.engine; console.log(engine.transport.name); // in most cases, prints &quot;polling&quot; engine.once(&quot;upgrade&quot;, () =&gt; { // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket) console.log(engine.transport.name); // in most cases, prints &quot;websocket&quot; }); engine.on(&quot;packet&quot;, ({ type, data }) =&gt; { // called for each packet received }); engine.on(&quot;packetCreate&quot;, ({ type, data }) =&gt; { // called for each packet sent }); engine.on(&quot;drain&quot;, () =&gt; { // called when the write buffer is drained }); engine.on(&quot;close&quot;, (reason) =&gt; { // called when the underlying connection is closed }); }); Copy "},{"title":"Lifecycle​","type":1,"pageTitle":"The Socket instance (client-side)","url":"docs/v1/client-socket-instance/#lifecycle","content":" "},{"title":"Events​","type":1,"pageTitle":"The Socket instance (client-side)","url":"docs/v1/client-socket-instance/#events","content":"The Socket instance emits three special events: connectconnect_errordisconnect Please note that since Socket.IO v3, the Socket instance does not emit any event related to the reconnection logic anymore. You can listen to the events on the Manager instance directly: socket.io.on(&quot;reconnect_attempt&quot;, () =&gt; { // ... }); socket.io.on(&quot;reconnect&quot;, () =&gt; { // ... }); Copy More information can be found in the migration guide. "},{"title":"connect​","type":1,"pageTitle":"The Socket instance (client-side)","url":"docs/v1/client-socket-instance/#connect","content":"This event is fired by the Socket instance upon connection and reconnection. socket.on(&quot;connect&quot;, () =&gt; { // ... }); Copy Please note that you shouldn't register event handlers in the connect handler itself, as a new handler will be registered every time the Socket reconnects: // BAD socket.on(&quot;connect&quot;, () =&gt; { socket.on(&quot;data&quot;, () =&gt; { /* ... */ }); }); // GOOD socket.on(&quot;connect&quot;, () =&gt; { // ... }); socket.on(&quot;data&quot;, () =&gt; { /* ... */ }); Copy "},{"title":"connect_error​","type":1,"pageTitle":"The Socket instance (client-side)","url":"docs/v1/client-socket-instance/#connect_error","content":"This event is fired when: the low-level connection cannot be establishedthe connection is denied by the server in a middleware function In the first case, the Socket will automatically try to reconnect, after a given delay. In the latter case, you need to manually reconnect. You might need to update the credentials: // either by directly modifying the `auth` attribute socket.on(&quot;connect_error&quot;, () =&gt; { socket.auth.token = &quot;abcd&quot;; socket.connect(); }); // or if the `auth` attribute is a function const socket = io({ auth: (cb) =&gt; { cb(localStorage.getItem(&quot;token&quot;)); } }); socket.on(&quot;connect_error&quot;, () =&gt; { setTimeout(() =&gt; { socket.connect(); }, 1000); }); Copy "},{"title":"disconnect​","type":1,"pageTitle":"The Socket instance (client-side)","url":"docs/v1/client-socket-instance/#disconnect","content":"This event is fired upon disconnection. socket.on(&quot;disconnect&quot;, (reason) =&gt; { // ... }); Copy Here is the list of possible reasons: Reason\tDescriptionio server disconnect\tThe server has forcefully disconnected the socket with socket.disconnect() io client disconnect\tThe socket was manually disconnected using socket.disconnect() ping timeout\tThe server did not send a PING within the pingInterval + pingTimeout range transport close\tThe connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G) transport error\tThe connection has encountered an error (example: the server was killed during a HTTP long-polling cycle) In the first two cases (explicit disconnection), the client will not try to reconnect and you need to manually call socket.connect(). In all other cases, the client will wait for a small random delay and then try to reconnect: socket.on(&quot;disconnect&quot;, (reason) =&gt; { if (reason === &quot;io server disconnect&quot;) { // the disconnection was initiated by the server, you need to reconnect manually socket.connect(); } // else the socket will automatically try to reconnect }); Copy Note: those events, along with disconnecting, newListener and removeListener, are special events that shouldn't be used in your application: // BAD, will throw an error socket.emit(&quot;disconnect&quot;); Copy "},{"title":"Complete API​","type":1,"pageTitle":"The Socket instance (client-side)","url":"docs/v1/client-socket-instance/#complete-api","content":"The complete API exposed by the Socket instance can be found here. "},{"title":"Logging and debugging","type":0,"sectionRef":"#","url":"docs/v1/logging-and-debugging/","content":"","keywords":""},{"title":"Available debugging scopes​","type":1,"pageTitle":"Logging and debugging","url":"docs/v1/logging-and-debugging/#available-debugging-scopes","content":"The best way to see what information is available is to use the *: DEBUG=* node yourfile.js Copy or in the browser: localStorage.debug = '*'; Copy And then filter by the scopes you’re interested in. You can prefix the * with scopes, separated by comma if there is more than one. For example, to only see debug statements from the socket.io client on Node.js try this: DEBUG=socket.io:client* node yourfile.js Copy To see all debug messages from the engine and socket.io: DEBUG=engine,socket.io* node yourfile.js Copy "},{"title":"Removing debug from your browser bundle​","type":1,"pageTitle":"Logging and debugging","url":"docs/v1/logging-and-debugging/#removing-debug-from-your-browser-bundle","content":"While useful during development, the debug package adds an extra weight to the final bundle (about 4KB minified and gzipped), that's why it is excluded from the slim bundle (more details about the various browser bundles can be found here). If you are using webpack, you can remove it with webpack-remove-debug: { module: { rules: [ { test: /\\.js$/, loader: 'webpack-remove-debug' } ] } } Copy "},{"title":"Error logs in the browser console​","type":1,"pageTitle":"Logging and debugging","url":"docs/v1/logging-and-debugging/#error-logs-in-the-browser-console","content":"Please note that error logs such as: net::ERR_INTERNET_DISCONNECTEDnet::ERR_CONNECTION_REFUSEDWebSocket is already in CLOSING or CLOSED stateCross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).The connection to xxx was interrupted while the page was loading are not emitted by the Socket.IO library but by the browser itself, and are therefore out of our control. "},{"title":"How it works","type":0,"sectionRef":"#","url":"docs/v1/how-it-works/","content":"","keywords":""},{"title":"Engine.IO​","type":1,"pageTitle":"How it works","url":"docs/v1/how-it-works/#engineio","content":"Engine.IO is responsible for establishing the low-level connection between the server and the client. It handles: the various transports and the upgrade mechanismthe disconnection detection The source code can be found here: server: https://github.com/socketio/engine.ioclient: https://github.com/socketio/engine.io-clientparser: https://github.com/socketio/engine.io-parserprotocol description: https://github.com/socketio/engine.io-protocol "},{"title":"Transports​","type":1,"pageTitle":"How it works","url":"docs/v1/how-it-works/#transports","content":"There are currently two implemented transports: HTTP long-pollingWebSocket HTTP long-polling​ The HTTP long-polling transport (also simply referred as &quot;polling&quot;) consists of successive HTTP requests: long-running GET requests, for receiving data from the servershort-running POST requests, for sending data to the server Due to the nature of the transport, successive emits may be concatenated and sent within the same HTTP request. WebSocket​ The WebSocket transport consists, well, of a WebSocket connection, which provides a bidirectional and low-latency communication channel between the server and the client. Due to the nature of the transport, each emit is sent in its own WebSocket frame (some emits may even result in two distinct WebSocket frames, more information here). "},{"title":"Handshake​","type":1,"pageTitle":"How it works","url":"docs/v1/how-it-works/#handshake","content":"At the beginning of the Engine.IO connection, the server sends some information: { &quot;sid&quot;: &quot;FSDjX-WRwSA4zTZMALqx&quot;, &quot;upgrades&quot;: [&quot;websocket&quot;], &quot;pingInterval&quot;: 25000, &quot;pingTimeout&quot;: 20000 } Copy the sid is the ID of the session, it must be included in the sid query parameter in all subsequent HTTP requeststhe upgrades array contains the list of all &quot;better&quot; transports that are supported by the serverthe pingInterval and pingTimeout values are used in the heartbeat mechanism "},{"title":"Upgrade mechanism​","type":1,"pageTitle":"How it works","url":"docs/v1/how-it-works/#upgrade-mechanism","content":"By default, the client establishes the connection with the HTTP long-polling transport. But, why? While WebSocket is clearly the best way to establish a bidirectional communication, experience has shown that it is not always possible to establish a WebSocket connection, due to corporate proxies, personal firewall, antivirus software... From the user perspective, an unsuccessful WebSocket connection can translate in up to at least 10 seconds of waiting for the realtime application to begin exchanging data. This perceptively hurts user experience. To summarize, Engine.IO focuses on reliability and user experience first, marginal potential UX improvements and increased server performance second. To upgrade, the client will: ensure its outgoing buffer is emptyput the current transport in read-only modetry to establish a connection with the other transportif successful, close the first transport You can check in the Network Monitor of your browser:  handshake (contains the session ID — here, zBjrh...AAAK — that is used in subsequent requests)send data (HTTP long-polling)receive data (HTTP long-polling)upgrade (WebSocket)receive data (HTTP long-polling, closed once the WebSocket connection in 4. is successfully established) "},{"title":"Disconnection detection​","type":1,"pageTitle":"How it works","url":"docs/v1/how-it-works/#disconnection-detection","content":"The Engine.IO connection is considered as closed when: one HTTP request (either GET or POST) fails (for example, when the server is shutdown)the WebSocket connection is closed (for example, when the user closes the tab in its browser)socket.disconnect() is called on the server-side or on the client-side There is also a heartbeat mechanism which checks that the connection between the server and the client is still up and running: At a given interval (the pingInterval value sent in the handshake) the server sends a PING packet and the client has a few seconds (the pingTimeout value) to send a PONG packet back. If the server does not receive a PONG packet back, it will consider that the connection is closed. Conversely, if the client does not receive a PING packet within pingInterval + pingTimeout, it will consider that the connection is closed. The disconnection reasons are listed here (server-side) and here (client-side). "},{"title":"Socket.IO​","type":1,"pageTitle":"How it works","url":"docs/v1/how-it-works/#socketio","content":"Socket.IO provides some additional features over the Engine.IO connection: automatic reconnectionpacket bufferingacknowledgmentsbroadcasting to all clients or to a subset of clients (what we call &quot;Room&quot;)multiplexing (what we call &quot;Namespace&quot;) The source code can be found here: server: https://github.com/socketio/socket.ioclient: https://github.com/socketio/socket.io-clientparser: https://github.com/socketio/socket.io-parserprotocol description: https://github.com/socketio/socket.io-protocol "},{"title":"Emitting events","type":0,"sectionRef":"#","url":"docs/v1/emitting-events/","content":"","keywords":""},{"title":"Basic emit​","type":1,"pageTitle":"Emitting events","url":"docs/v1/emitting-events/#basic-emit","content":"The Socket.IO API is inspired from the Node.js EventEmitter, which means you can emit events on one side and register listeners on the other: Server io.on(&quot;connection&quot;, (socket) =&gt; { socket.emit(&quot;hello&quot;, &quot;world&quot;); }); Copy Client socket.on(&quot;hello&quot;, (arg) =&gt; { console.log(arg); // world }); Copy This also works in the other direction: Server io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;hello&quot;, (arg) =&gt; { console.log(arg); // world }); }); Copy Client socket.emit(&quot;hello&quot;, &quot;world&quot;); Copy You can send any number of arguments, and all serializable datastructures are supported, including binary objects like Buffer or TypedArray. Server io.on(&quot;connection&quot;, (socket) =&gt; { socket.emit(&quot;hello&quot;, 1, &quot;2&quot;, { 3: '4', 5: Buffer.from([6]) }); }); Copy Client // client-side socket.on(&quot;hello&quot;, (arg1, arg2, arg3) =&gt; { console.log(arg1); // 1 console.log(arg2); // &quot;2&quot; console.log(arg3); // { 3: '4', 5: ArrayBuffer (1) [ 6 ] } }); Copy There is no need to run JSON.stringify() on objects as it will be done for you. // BAD socket.emit(&quot;hello&quot;, JSON.stringify({ name: &quot;John&quot; })); // GOOD socket.emit(&quot;hello&quot;, { name: &quot;John&quot; }); Copy Notes: Date objects will be converted to (and received as) their string representation, e.g. 1970-01-01T00:00:00.000Z Map and Set must be manually serialized: const serializedMap = [...myMap.entries()]; const serializedSet = [...mySet.keys()]; Copy you can use the toJSON() method to customize the serialization of an object Example with a class: class Hero { #hp; constructor() { this.#hp = 42; } toJSON() { return { hp: this.#hp }; } } socket.emit(&quot;here's a hero&quot;, new Hero()); Copy "},{"title":"Acknowledgements​","type":1,"pageTitle":"Emitting events","url":"docs/v1/emitting-events/#acknowledgements","content":"Events are great, but in some cases you may want a more classic request-response API. In Socket.IO, this feature is named acknowledgements. You can add a callback as the last argument of the emit(), and this callback will be called once the other side acknowledges the event: Server io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;update item&quot;, (arg1, arg2, callback) =&gt; { console.log(arg1); // 1 console.log(arg2); // { name: &quot;updated&quot; } callback({ status: &quot;ok&quot; }); }); }); Copy Client socket.emit(&quot;update item&quot;, &quot;1&quot;, { name: &quot;updated&quot; }, (response) =&gt; { console.log(response.status); // ok }); Copy "},{"title":"With timeout​","type":1,"pageTitle":"Emitting events","url":"docs/v1/emitting-events/#with-timeout","content":"Starting with Socket.IO v4.4.0, you can now assign a timeout to each emit: socket.timeout(5000).emit(&quot;my-event&quot;, (err) =&gt; { if (err) { // the other side did not acknowledge the event in the given delay } }); Copy You can also use both a timeout and an acknowledgement: socket.timeout(5000).emit(&quot;my-event&quot;, (err, response) =&gt; { if (err) { // the other side did not acknowledge the event in the given delay } else { console.log(response); } }); Copy "},{"title":"Volatile events​","type":1,"pageTitle":"Emitting events","url":"docs/v1/emitting-events/#volatile-events","content":"Volatile events are events that will not be sent if the underlying connection is not ready (a bit like UDP, in terms of reliability). This can be interesting for example if you need to send the position of the characters in an online game (as only the latest values are useful). socket.volatile.emit(&quot;hello&quot;, &quot;might or might not be received&quot;); Copy Another use case is to discard events when the client is not connected (by default, the events are buffered until reconnection). Example: Server io.on(&quot;connection&quot;, (socket) =&gt; { console.log(&quot;connect&quot;); socket.on(&quot;ping&quot;, (count) =&gt; { console.log(count); }); }); Copy Client let count = 0; setInterval(() =&gt; { socket.volatile.emit(&quot;ping&quot;, ++count); }, 1000); Copy If you restart the server, you will see in the console: connect 1 2 3 4 # the server is restarted, the client automatically reconnects connect 9 10 11 Copy Without the volatile flag, you would see: connect 1 2 3 4 # the server is restarted, the client automatically reconnects and sends its buffered events connect 5 6 7 8 9 10 11 Copy "},{"title":"Application structure","type":0,"sectionRef":"#","url":"docs/v1/server-application-structure/","content":"","keywords":""},{"title":"Registering event handlers​","type":1,"pageTitle":"Application structure","url":"docs/v1/server-application-structure/#registering-event-handlers","content":"You will find below two suggestions on how to register your event handlers. Please note that these are merely suggestions and not strict guidelines that you must follow. Please adapt it to your own liking! "},{"title":"Each file registers its own event handlers​","type":1,"pageTitle":"Application structure","url":"docs/v1/server-application-structure/#each-file-registers-its-own-event-handlers","content":"Here, the entrypoint is kept tidy, but the event listeners may be less discoverable (though strong naming convention/ctrl+f will help). index.js const httpServer = require(&quot;http&quot;).createServer(); const io = require(&quot;socket.io&quot;)(httpServer); const registerOrderHandlers = require(&quot;./orderHandler&quot;); const registerUserHandlers = require(&quot;./userHandler&quot;); const onConnection = (socket) =&gt; { registerOrderHandlers(io, socket); registerUserHandlers(io, socket); } io.on(&quot;connection&quot;, onConnection); Copy orderHandler.js module.exports = (io, socket) =&gt; { const createOrder = (payload) =&gt; { // ... } const readOrder = (orderId, callback) =&gt; { // ... } socket.on(&quot;order:create&quot;, createOrder); socket.on(&quot;order:read&quot;, readOrder); } Copy "},{"title":"All event handlers are registered in the index.js file​","type":1,"pageTitle":"Application structure","url":"docs/v1/server-application-structure/#all-event-handlers-are-registered-in-the-indexjs-file","content":"Here, each event name is located in the same place, which is great for discoverability, but could get out of hand in a medium/big application. index.js const httpServer = require(&quot;http&quot;).createServer(); const io = require(&quot;socket.io&quot;)(httpServer); const { createOrder, readOrder } = require(&quot;./orderHandler&quot;)(io); const { updatePassword } = require(&quot;./userHandler&quot;)(io); const onConnection = (socket) =&gt; { socket.on(&quot;order:create&quot;, createOrder); socket.on(&quot;order:read&quot;, readOrder); socket.on(&quot;user:update-password&quot;, updatePassword); } io.on(&quot;connection&quot;, onConnection); Copy orderHandler.js module.exports = (io) =&gt; { const createOrder = function (payload) { const socket = this; // hence the 'function' above, as an arrow function will not work // ... }; const readOrder = function (orderId, callback) { // ... }; return { createOrder, readOrder } } Copy "},{"title":"Rooms","type":0,"sectionRef":"#","url":"docs/v1/rooms/","content":"","keywords":""},{"title":"Joining and leaving​","type":1,"pageTitle":"Rooms","url":"docs/v1/rooms/#joining-and-leaving","content":"You can call join to subscribe the socket to a given channel: io.on(&quot;connection&quot;, (socket) =&gt; { socket.join(&quot;some room&quot;); }); Copy And then simply use to or in (they are the same) when broadcasting or emitting: io.to(&quot;some room&quot;).emit(&quot;some event&quot;); Copy You can emit to several rooms at the same time: io.to(&quot;room1&quot;).to(&quot;room2&quot;).to(&quot;room3&quot;).emit(&quot;some event&quot;); Copy In that case, a union is performed: every socket that is at least in one of the rooms will get the event once (even if the socket is in two or more rooms). You can also broadcast to a room from a given socket: io.on(&quot;connection&quot;, (socket) =&gt; { socket.to(&quot;some room&quot;).emit(&quot;some event&quot;); }); Copy In that case, every socket in the room excluding the sender will get the event.   To leave a channel you call leave in the same fashion as join. "},{"title":"Default room​","type":1,"pageTitle":"Rooms","url":"docs/v1/rooms/#default-room","content":"Each Socket in Socket.IO is identified by a random, unguessable, unique identifier Socket#id. For your convenience, each socket automatically joins a room identified by its own id. This makes it easy to implement private messages: io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;private message&quot;, (anotherSocketId, msg) =&gt; { socket.to(anotherSocketId).emit(&quot;private message&quot;, socket.id, msg); }); }); Copy "},{"title":"Sample use cases​","type":1,"pageTitle":"Rooms","url":"docs/v1/rooms/#sample-use-cases","content":"broadcast data to each device / tab of a given user io.on(&quot;connection&quot;, async (socket) =&gt; { const userId = await fetchUserId(socket); socket.join(userId); // and then later io.to(userId).emit(&quot;hi&quot;); }); Copy send notifications about a given entity io.on(&quot;connection&quot;, async (socket) =&gt; { const projects = await fetchProjects(socket); projects.forEach(project =&gt; socket.join(&quot;project:&quot; + project.id)); // and then later io.to(&quot;project:4321&quot;).emit(&quot;project updated&quot;); }); Copy "},{"title":"Disconnection​","type":1,"pageTitle":"Rooms","url":"docs/v1/rooms/#disconnection","content":"Upon disconnection, sockets leave all the channels they were part of automatically, and no special teardown is needed on your part. You can fetch the rooms the Socket was in by listening to the disconnecting event: io.on(&quot;connection&quot;, socket =&gt; { socket.on(&quot;disconnecting&quot;, () =&gt; { console.log(socket.rooms); // the Set contains at least the socket ID }); socket.on(&quot;disconnect&quot;, () =&gt; { // socket.rooms.size === 0 }); }); Copy "},{"title":"With multiple Socket.IO servers​","type":1,"pageTitle":"Rooms","url":"docs/v1/rooms/#with-multiple-socketio-servers","content":"Like global broadcasting, broadcasting to rooms also works with multiple Socket.IO servers. You just need to replace the default Adapter by the Redis Adapter. More information about it here.   "},{"title":"Implementation details​","type":1,"pageTitle":"Rooms","url":"docs/v1/rooms/#implementation-details","content":"The &quot;room&quot; feature is implemented by what we call an Adapter. This Adapter is a server-side component which is responsible for: storing the relationships between the Socket instances and the roomsbroadcasting events to all (or a subset of) clients You can find the code of the default in-memory adapter here. Basically, it consists in two ES6 Maps: sids: Map&lt;SocketId, Set&lt;Room&gt;&gt;rooms: Map&lt;Room, Set&lt;SocketId&gt;&gt; Calling socket.join(&quot;the-room&quot;) will result in: in the ̀sids Map, adding &quot;the-room&quot; to the Set identified by the socket IDin the rooms Map, adding the socket ID in the Set identified by the string &quot;the-room&quot; Those two maps are then used when broadcasting: a broadcast to all sockets (io.emit()) loops through the sids Map, and send the packet to all socketsa broadcast to a given room (io.to(&quot;room21&quot;).emit()) loops through the Set in the rooms Map, and sends the packet to all matching sockets You can access those objects with: // main namespace const rooms = io.of(&quot;/&quot;).adapter.rooms; const sids = io.of(&quot;/&quot;).adapter.sids; // custom namespace const rooms = io.of(&quot;/my-namespace&quot;).adapter.rooms; const sids = io.of(&quot;/my-namespace&quot;).adapter.sids; Copy Notes: those objects are not meant to be directly modified, you should always use socket.join(...) and socket.leave(...) instead.in a multi-server setup, the rooms and sids objects are not shared between the Socket.IO servers (a room may only &quot;exist&quot; on one server and not on another). "},{"title":"Room events​","type":1,"pageTitle":"Rooms","url":"docs/v1/rooms/#room-events","content":"Starting with socket.io@3.1.0, the underlying Adapter will emit the following events: create-room (argument: room)delete-room (argument: room)join-room (argument: room, id)leave-room (argument: room, id) Example: io.of(&quot;/&quot;).adapter.on(&quot;create-room&quot;, (room) =&gt; { console.log(`room ${room} was created`); }); io.of(&quot;/&quot;).adapter.on(&quot;join-room&quot;, (room, id) =&gt; { console.log(`socket ${id} has joined room ${room}`); }); Copy "},{"title":"Behind a reverse proxy","type":0,"sectionRef":"#","url":"docs/v1/reverse-proxy/","content":"","keywords":""},{"title":"NginX​","type":1,"pageTitle":"Behind a reverse proxy","url":"docs/v1/reverse-proxy/#nginx","content":"Content of /etc/nginx/nginx.conf: http { server { listen 80; server_name example.com; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; } } } Copy Related: proxy_pass documentationconfiguration in a multi-server setup If you only want to forward the Socket.IO requests (for example when NginX handles the static content): http { server { listen 80; root /var/www/html; location /socket.io/ { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; } } } Copy "},{"title":"Apache HTTPD​","type":1,"pageTitle":"Behind a reverse proxy","url":"docs/v1/reverse-proxy/#apache-httpd","content":"Content of /usr/local/apache2/conf/httpd.conf: Listen 80 ServerName example.com LoadModule mpm_event_module modules/mod_mpm_event.so LoadModule authn_file_module modules/mod_authn_file.so LoadModule authn_core_module modules/mod_authn_core.so LoadModule authz_host_module modules/mod_authz_host.so LoadModule authz_groupfile_module modules/mod_authz_groupfile.so LoadModule authz_user_module modules/mod_authz_user.so LoadModule authz_core_module modules/mod_authz_core.so LoadModule headers_module modules/mod_headers.so LoadModule lbmethod_byrequests_module modules/mod_lbmethod_byrequests.so LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_balancer_module modules/mod_proxy_balancer.so LoadModule proxy_http_module modules/mod_proxy_http.so LoadModule proxy_wstunnel_module modules/mod_proxy_wstunnel.so LoadModule rewrite_module modules/mod_rewrite.so LoadModule slotmem_shm_module modules/mod_slotmem_shm.so LoadModule unixd_module modules/mod_unixd.so User daemon Group daemon ProxyPass / http://localhost:3000/ RewriteEngine on RewriteCond %{HTTP:Upgrade} websocket [NC] RewriteCond %{HTTP:Connection} upgrade [NC] RewriteRule ^/?(.*) &quot;ws://localhost:3000/$1&quot; [P,L] ProxyTimeout 3 Copy Related: mod_proxy_wstunnel documentationconfiguration in a multi-server setup "},{"title":"Node.js http-proxy​","type":1,"pageTitle":"Behind a reverse proxy","url":"docs/v1/reverse-proxy/#nodejs-http-proxy","content":"Installation: npm i http-proxy const httpProxy = require(&quot;http-proxy&quot;); httpProxy .createProxyServer({ target: &quot;http://localhost:3000&quot;, ws: true, }) .listen(80); Copy Documentation "},{"title":"Server Installation","type":0,"sectionRef":"#","url":"docs/v1/server-installation/","content":"","keywords":""},{"title":"Prerequisites​","type":1,"pageTitle":"Server Installation","url":"docs/v1/server-installation/#prerequisites","content":"Please make sure that Node.js is installed on your system. The current Long Term Support (LTS) release is an ideal starting point, see here. info At least Node.js 10 is needed, older versions are not supported anymore. "},{"title":"Installation​","type":1,"pageTitle":"Server Installation","url":"docs/v1/server-installation/#installation","content":"To install the latest release: NPMYarnpnpm npm install socket.io Copy To install a specific version: NPMYarnpnpm npm install socket.io@version Copy "},{"title":"Latest releases​","type":1,"pageTitle":"Server Installation","url":"docs/v1/server-installation/#latest-releases","content":"4.5.0 (2022/04/23): GitHub release / diff / npm4.4.1 (2022/01/06): GitHub release / diff / npm4.4.0 (2021/11/18): GitHub release / diff / npm4.3.2 (2021/11/08): GitHub release / diff / npm4.3.1 (2021/10/17): GitHub release / diff / npm4.3.0 (2021/10/15): GitHub release / diff / npm4.2.0 (2021/08/30): GitHub release / diff / npm "},{"title":"Additional packages​","type":1,"pageTitle":"Server Installation","url":"docs/v1/server-installation/#additional-packages","content":"By default, Socket.IO use the WebSocket server provided by the ws package. There are 2 optional packages that can be installed alongside this package. These packages are binary add-ons which improve certain operations. Prebuilt binaries are available for the most popular platforms so you don't necessarily need to have a C++ compiler installed on your machine. bufferutil: Allows to efficiently perform operations such as masking and unmasking the data payload of the WebSocket frames.utf-8-validate: Allows to efficiently check if a message contains valid UTF-8 as required by the spec. To install those packages: NPMYarnpnpm npm install --save-optional bufferutil utf-8-validate Copy Please note that these packages are optional, the WebSocket server will fallback to the Javascript implementation if they are not available. More information can be found here. "},{"title":"Other WebSocket server implementations​","type":1,"pageTitle":"Server Installation","url":"docs/v1/server-installation/#other-websocket-server-implementations","content":"Any Websocket server implementation which exposes the same API as ws (notably the handleUpgrade method) can be used. For example, you can use the eiows package, which is a fork of the (now deprecated) uws package: NPMYarnpnpm npm install eiows Copy And then use the wsEngine option: const { Server } = require(&quot;socket.io&quot;); const eiows = require(&quot;eiows&quot;); const io = new Server(3000, { wsEngine: eiows.Server }); Copy This implementation &quot;allows, but doesn't guarantee&quot; significant performance and memory-usage improvements over the default implementation. As usual, please benchmark it against your own usage. "},{"title":"Usage with µWebSockets.js​","type":1,"pageTitle":"Server Installation","url":"docs/v1/server-installation/#usage-with-uwebsockets","content":"Starting with version 4.4.0, a Socket.IO server can now bind to a µWebSockets.js server. Installation: NPMYarnpnpm npm install uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0 Copy Usage: const { App } = require(&quot;uWebSockets.js&quot;); const { Server } = require(&quot;socket.io&quot;); const app = new App(); const io = new Server(); io.attachApp(app); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); app.listen(3000, (token) =&gt; { if (!token) { console.warn(&quot;port already in use&quot;); } }); Copy "},{"title":"Miscellaneous​","type":1,"pageTitle":"Server Installation","url":"docs/v1/server-installation/#miscellaneous","content":""},{"title":"Dependency tree​","type":1,"pageTitle":"Server Installation","url":"docs/v1/server-installation/#dependency-tree","content":"A basic installation of the server includes 23 packages: └─┬ socket.io@4.5.0 ├─┬ accepts@1.3.8 │ ├─┬ mime-types@2.1.35 │ │ └── mime-db@1.52.0 │ └── negotiator@0.6.3 ├── base64id@2.0.0 ├─┬ debug@4.3.4 │ └── ms@2.1.2 ├─┬ engine.io@6.2.0 │ ├── @types/cookie@0.4.1 │ ├── @types/cors@2.8.12 │ ├── @types/node@17.0.26 │ ├── accepts@1.3.8 deduped │ ├── base64id@2.0.0 deduped │ ├── cookie@0.4.2 │ ├─┬ cors@2.8.5 │ │ ├── object-assign@4.1.1 │ │ └── vary@1.1.2 │ ├── debug@4.3.4 deduped │ ├─┬ engine.io-parser@5.0.3 │ │ └── @socket.io/base64-arraybuffer@1.0.2 │ └─┬ ws@8.2.3 │ ├── UNMET OPTIONAL DEPENDENCY bufferutil@^4.0.1 │ └── UNMET OPTIONAL DEPENDENCY utf-8-validate@^5.0.2 ├── socket.io-adapter@2.4.0 └─┬ socket.io-parser@4.0.4 ├── @types/component-emitter@1.2.11 ├── component-emitter@1.3.0 └── debug@4.3.4 deduped Copy info The type declarations for 3rd party packages are included, in order to ease the use of the library for TypeScript users (but at the cost of a slightly-larger package). See also: https://github.com/microsoft/types-publisher/issues/81#issuecomment-234051345 "},{"title":"Transitive versions​","type":1,"pageTitle":"Server Installation","url":"docs/v1/server-installation/#transitive-versions","content":"The engine.io package brings the engine that is responsible for managing the low-level connections (HTTP long-polling or WebSocket). See also: How it works socket.io version\tengine.io version\tws version4.5.x\t6.2.x\t8.2.x 4.4.x\t6.1.x\t8.2.x 4.3.x\t6.0.x\t8.2.x 4.2.x\t5.2.x\t7.4.x 4.1.x\t5.1.x\t7.4.x 4.0.x\t5.0.x\t7.4.x 3.1.x\t4.1.x\t7.4.x 3.0.x\t4.0.x\t7.4.x 2.4.x\t3.5.x\t7.4.x "},{"title":"Client API","type":0,"sectionRef":"#","url":"docs/v1/client-api/","content":"","keywords":""},{"title":"IO​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#io","content":"The io method is bound to the global scope in the standalone build: &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const socket = io(); &lt;/script&gt; Copy An ESM bundle is also available since version 4.3.0: &lt;script type=&quot;module&quot;&gt; import { io } from &quot;https://cdn.socket.io/4.4.1/socket.io.esm.min.js&quot;; const socket = io(); &lt;/script&gt; Copy With an import map: &lt;script type=&quot;importmap&quot;&gt; { &quot;imports&quot;: { &quot;socket.io-client&quot;: &quot;https://cdn.socket.io/4.4.1/socket.io.esm.min.js&quot; } } &lt;/script&gt; &lt;script type=&quot;module&quot;&gt; import { io } from &quot;socket.io-client&quot;; const socket = io(); &lt;/script&gt; Copy Else, in all other cases (with some build tools, in Node.js or React Native), it can be imported from the socket.io-client package: // ES modules import { io } from &quot;socket.io-client&quot;; // CommonJS const { io } = require(&quot;socket.io-client&quot;); Copy "},{"title":"io.protocol​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#ioprotocol","content":"&lt;number&gt; The protocol revision number (currently: 5). The protocol defines the format of the packets exchanged between the client and the server. Both the client and the server must use the same revision in order to understand each other. You can find more information here. "},{"title":"io([url][, options])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#iourl","content":"url &lt;string&gt; (defaults to window.location)options &lt;Object&gt; forceNew &lt;boolean&gt; whether to create a new connection Returns &lt;Socket&gt; Creates a new Manager for the given URL, and attempts to reuse an existing Manager for subsequent calls, unless the multiplex option is passed with false. Passing this option is the equivalent of passing &quot;force new connection&quot;: true or forceNew: true. A new Socket instance is returned for the namespace specified by the pathname in the URL, defaulting to /. For example, if the url is http://localhost/users, a transport connection will be established to http://localhost and a Socket.IO connection will be established to /users. Query parameters can also be provided, either with the query option or directly in the url (example: http://localhost/users?token=abc). To understand what happens under the hood, the following example: import { io } from &quot;socket.io-client&quot;; const socket = io(&quot;ws://example.com/my-namespace&quot;, { reconnectionDelayMax: 10000, auth: { token: &quot;123&quot; }, query: { &quot;my-key&quot;: &quot;my-value&quot; } }); Copy is the short version of: import { Manager } from &quot;socket.io-client&quot;; const manager = new Manager(&quot;ws://example.com&quot;, { reconnectionDelayMax: 10000, query: { &quot;my-key&quot;: &quot;my-value&quot; } }); const socket = manager.socket(&quot;/my-namespace&quot;, { auth: { token: &quot;123&quot; } }); Copy The complete list of available options can be found here. "},{"title":"Manager​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#manager","content":"  The Manager manages the Engine.IO client instance, which is the low-level engine that establishes the connection to the server (by using transports like WebSocket or HTTP long-polling). The Manager handles the reconnection logic. A single Manager can be used by several Sockets. You can find more information about this multiplexing feature here. Please note that, in most cases, you won't use the Manager directly but use the Socket instance instead. "},{"title":"new Manager(url[, options])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#new-managerurl-options","content":"url &lt;string&gt;options &lt;Object&gt;Returns &lt;Manager&gt; The complete list of available options can be found here. import { Manager } from &quot;socket.io-client&quot;; const manager = new Manager(&quot;https://example.com&quot;); const socket = manager.socket(&quot;/&quot;); // main namespace const adminSocket = manager.socket(&quot;/admin&quot;); // admin namespace Copy "},{"title":"manager.reconnection([value])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#managerreconnectionvalue","content":"value &lt;boolean&gt;Returns &lt;Manager&gt; | &lt;boolean&gt; Sets the reconnection option, or returns it if no parameters are passed. "},{"title":"manager.reconnectionAttempts([value])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#managerreconnectionattemptsvalue","content":"value &lt;number&gt;Returns &lt;Manager&gt; | &lt;number&gt; Sets the reconnectionAttempts option, or returns it if no parameters are passed. "},{"title":"manager.reconnectionDelay([value])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#managerreconnectiondelayvalue","content":"value &lt;number&gt;Returns &lt;Manager&gt; | &lt;number&gt; Sets the reconnectionDelay option, or returns it if no parameters are passed. "},{"title":"manager.reconnectionDelayMax([value])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#managerreconnectiondelaymaxvalue","content":"value &lt;number&gt;Returns &lt;Manager&gt; | &lt;number&gt; Sets the reconnectionDelayMax option, or returns it if no parameters are passed. "},{"title":"manager.timeout([value])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#managertimeoutvalue","content":"value &lt;number&gt;Returns &lt;Manager&gt; | &lt;number&gt; Sets the timeout option, or returns it if no parameters are passed. "},{"title":"manager.open([callback])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#manageropencallback","content":"callback &lt;Function&gt;Returns &lt;Manager&gt; If the manager was initiated with autoConnect to false, launch a new connection attempt. The callback argument is optional and will be called once the attempt fails/succeeds. import { Manager } from &quot;socket.io-client&quot;; const manager = new Manager(&quot;https://example.com&quot;, { autoConnect: false }); const socket = manager.socket(&quot;/&quot;); manager.open((err) =&gt; { if (err) { // an error has occurred } else { // the connection was successfully established } }); Copy "},{"title":"manager.connect([callback])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#managerconnectcallback","content":"Synonym of manager.open([callback]). "},{"title":"manager.socket(nsp, options)​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#managersocketnsp-options","content":"nsp &lt;string&gt;options &lt;Object&gt;Returns &lt;Socket&gt; Creates a new Socket for the given namespace. Only auth ({ auth: {key: &quot;value&quot;} }) is read from the options object. Other keys will be ignored and should be passed when instancing a new Manager(nsp, options). "},{"title":"Event: 'error'​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#event-error","content":"error &lt;Error&gt; error object Fired upon a connection error. socket.io.on(&quot;error&quot;, (error) =&gt; { // ... }); Copy "},{"title":"Event: 'reconnect'​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#event-reconnect","content":"attempt &lt;number&gt; reconnection attempt number Fired upon a successful reconnection. socket.io.on(&quot;reconnect&quot;, (attempt) =&gt; { // ... }); Copy "},{"title":"Event: 'reconnect_attempt'​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#event-reconnect_attempt","content":"attempt &lt;number&gt; reconnection attempt number Fired upon an attempt to reconnect. socket.io.on(&quot;reconnect_attempt&quot;, (attempt) =&gt; { // ... }); Copy "},{"title":"Event: 'reconnect_error'​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#event-reconnect_error","content":"error &lt;Error&gt; error object Fired upon a reconnection attempt error. socket.io.on(&quot;reconnect_error&quot;, (error) =&gt; { // ... }); Copy "},{"title":"Event: 'reconnect_failed'​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#event-reconnect_failed","content":"Fired when couldn't reconnect within reconnectionAttempts. socket.io.on(&quot;reconnect_failed&quot;, () =&gt; { // ... }); Copy "},{"title":"Event: 'ping'​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#event-ping","content":"Fired when a ping packet is received from the server. socket.io.on(&quot;ping&quot;, () =&gt; { // ... }); Copy "},{"title":"Socket​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socket","content":"  A Socket is the fundamental class for interacting with the server. A Socket belongs to a certain Namespace (by default /) and uses an underlying Manager to communicate. A Socket is basically an EventEmitter which sends events to — and receive events from — the server over the network. socket.emit(&quot;hello&quot;, { a: &quot;b&quot;, c: [] }); socket.on(&quot;hey&quot;, (...args) =&gt; { // ... }); Copy More information can be found here. "},{"title":"socket.id​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketid","content":"&lt;string&gt; An unique identifier for the socket session. Set after the connect event is triggered, and updated after the reconnect event. const socket = io(&quot;http://localhost&quot;); console.log(socket.id); // undefined socket.on(&quot;connect&quot;, () =&gt; { console.log(socket.id); // &quot;G5p5...&quot; }); Copy "},{"title":"socket.connected​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketconnected","content":"&lt;boolean&gt; Whether or not the socket is connected to the server. const socket = io(&quot;http://localhost&quot;); socket.on(&quot;connect&quot;, () =&gt; { console.log(socket.connected); // true }); Copy "},{"title":"socket.disconnected​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketdisconnected","content":"&lt;boolean&gt; Whether or not the socket is disconnected from the server. const socket = io(&quot;http://localhost&quot;); socket.on(&quot;connect&quot;, () =&gt; { console.log(socket.disconnected); // false }); Copy "},{"title":"socket.io​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketio","content":"&lt;Manager&gt; A reference to the underlying Manager. socket.on(&quot;connect&quot;, () =&gt; { const engine = socket.io.engine; console.log(engine.transport.name); // in most cases, prints &quot;polling&quot; engine.once(&quot;upgrade&quot;, () =&gt; { // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket) console.log(engine.transport.name); // in most cases, prints &quot;websocket&quot; }); engine.on(&quot;packet&quot;, ({ type, data }) =&gt; { // called for each packet received }); engine.on(&quot;packetCreate&quot;, ({ type, data }) =&gt; { // called for each packet sent }); engine.on(&quot;drain&quot;, () =&gt; { // called when the write buffer is drained }); engine.on(&quot;close&quot;, (reason) =&gt; { // called when the underlying connection is closed }); }); Copy "},{"title":"socket.connect()​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketconnect","content":"Added in v1.0.0 Returns Socket Manually connects the socket. const socket = io({ autoConnect: false }); // ... socket.connect(); Copy It can also be used to manually reconnect: socket.on(&quot;disconnect&quot;, () =&gt; { socket.connect(); }); Copy "},{"title":"socket.open()​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketopen","content":"Added in v1.0.0 Synonym of socket.connect(). "},{"title":"socket.send([...args][, ack])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketsendargs","content":"args &lt;any[]&gt;ack &lt;Function&gt;Returns &lt;Socket&gt; Sends a message event. See socket.emit(eventName[, ...args][, ack]). "},{"title":"socket.emit(eventName[, ...args][, ack])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketemiteventname-args","content":"eventName &lt;string&gt; | &lt;symbol&gt;args &lt;any[]&gt;ack &lt;Function&gt;Returns true Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable datastructures are supported, including Buffer. socket.emit(&quot;hello&quot;, &quot;world&quot;); socket.emit(&quot;with-binary&quot;, 1, &quot;2&quot;, { 3: &quot;4&quot;, 5: Buffer.from([6, 7, 8]) }); Copy The ack argument is optional and will be called with the server answer. Client socket.emit(&quot;hello&quot;, &quot;world&quot;, (response) =&gt; { console.log(response); // &quot;got it&quot; }); Copy Server io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;hello&quot;, (arg, callback) =&gt; { console.log(arg); // &quot;world&quot; callback(&quot;got it&quot;); }); }); Copy "},{"title":"socket.on(eventName, callback)​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketoneventname-callback","content":"Inherited from the EventEmitter class. eventName &lt;string&gt; | &lt;symbol&gt;listener &lt;Function&gt;Returns &lt;Socket&gt; Register a new handler for the given event. socket.on(&quot;news&quot;, (data) =&gt; { console.log(data); }); // with multiple arguments socket.on(&quot;news&quot;, (arg1, arg2, arg3, arg4) =&gt; { // ... }); // with callback socket.on(&quot;news&quot;, (cb) =&gt; { cb(0); }); Copy "},{"title":"socket.once(eventName, callback)​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketonceeventname-callback","content":"Inherited from the EventEmitter class. eventName &lt;string&gt; | &lt;symbol&gt;listener &lt;Function&gt;Returns &lt;Socket&gt; Adds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked. socket.once(&quot;my-event&quot;, () =&gt; { // ... }); Copy "},{"title":"socket.off([eventName][, listener])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketoffeventname","content":"Inherited from the EventEmitter class. eventName &lt;string&gt; | &lt;symbol&gt;listener &lt;Function&gt;Returns &lt;Socket&gt; Removes the specified listener from the listener array for the event named eventName. const myListener = () =&gt; { // ... } socket.on(&quot;my-event&quot;, myListener); // then later socket.off(&quot;my-event&quot;, myListener); Copy The listener argument can also be omitted: // remove all listeners for that event socket.off(&quot;my-event&quot;); // remove all listeners for all events socket.off(); Copy "},{"title":"socket.listeners(eventName)​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketlistenerseventname","content":"Inherited from the EventEmitter class. eventName &lt;string&gt; | &lt;symbol&gt;Returns &lt;Function[]&gt; Returns the array of listeners for the event named eventName. socket.on(&quot;my-event&quot;, () =&gt; { // ... }); console.log(socket.listeners(&quot;my-event&quot;)); // prints [ [Function] ] Copy "},{"title":"socket.onAny(callback)​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketonanycallback","content":"Added in v3.0.0 callback &lt;Function&gt; Register a new catch-all listener. socket.onAny((event, ...args) =&gt; { console.log(`got ${event}`); }); Copy "},{"title":"socket.prependAny(callback)​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketprependanycallback","content":"Added in v3.0.0 callback &lt;Function&gt; Register a new catch-all listener. The listener is added to the beginning of the listeners array. socket.prependAny((event, ...args) =&gt; { console.log(`got ${event}`); }); Copy "},{"title":"socket.offAny([listener])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketoffanylistener","content":"Added in v3.0.0 listener &lt;Function&gt; Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed. const myListener = () =&gt; { /* ... */ }; socket.onAny(myListener); // then, later socket.offAny(myListener); socket.offAny(); Copy "},{"title":"socket.listenersAny()​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketlistenersany","content":"Added in v3.0.0 Returns &lt;Function[]&gt; Returns the list of registered catch-all listeners. const listeners = socket.listenersAny(); Copy "},{"title":"socket.onAnyOutgoing(callback)​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketonanyoutgoingcallback","content":"Added in v4.5.0 callback &lt;Function&gt; Register a new catch-all listener for outgoing packets. socket.onAnyOutgoing((event, ...args) =&gt; { console.log(`got ${event}`); }); Copy "},{"title":"socket.prependAnyOutgoing(callback)​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketprependanyoutgoingcallback","content":"Added in v4.5.0 callback &lt;Function&gt; Register a new catch-all listener for outgoing packets. The listener is added to the beginning of the listeners array. socket.prependAnyOutgoing((event, ...args) =&gt; { console.log(`got ${event}`); }); Copy "},{"title":"socket.offAnyOutgoing([listener])​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketoffanyoutgoinglistener","content":"Added in v4.5.0 listener &lt;Function&gt; Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed. const myListener = () =&gt; { /* ... */ }; socket.onAnyOutgoing(myListener); // remove a single listener socket.offAnyOutgoing(myListener); // remove all listeners socket.offAnyOutgoing(); Copy "},{"title":"socket.listenersAnyOutgoing()​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketlistenersanyoutgoing","content":"Added in v4.5.0 Returns &lt;Function[]&gt; Returns the list of registered catch-all listeners for outgoing packets. const listeners = socket.listenersAnyOutgoing(); Copy "},{"title":"socket.compress(value)​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketcompressvalue","content":"value &lt;boolean&gt;Returns &lt;Socket&gt; Sets a modifier for a subsequent event emission that the event data will only be compressed if the value is true. Defaults to true when you don't call the method. socket.compress(false).emit(&quot;an event&quot;, { some: &quot;data&quot; }); Copy "},{"title":"socket.timeout(value)​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#sockettimeoutvalue","content":"Added in v4.4.0 value &lt;number&gt;Returns &lt;Socket&gt; Sets a modifier for a subsequent event emission that the callback will be called with an error when the given number of milliseconds have elapsed without an acknowledgement from the server: socket.timeout(5000).emit(&quot;my-event&quot;, (err) =&gt; { if (err) { // the server did not acknowledge the event in the given delay } }); Copy "},{"title":"socket.disconnect()​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketdisconnect","content":"Added in v1.0.0 Returns &lt;Socket&gt; Manually disconnects the socket. In that case, the socket will not try to reconnect. Associated disconnection reason: client-side: &quot;io client disconnect&quot;server-side: &quot;client namespace disconnect&quot; If this is the last active Socket instance of the Manager, the low-level connection will be closed. "},{"title":"socket.close()​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#socketclose","content":"Added in v1.0.0 Synonym of socket.disconnect(). "},{"title":"Flag: 'volatile'​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#flag-volatile","content":"Added in v3.0.0 Sets a modifier for the subsequent event emission indicating that the packet may be dropped if: the socket is not connectedthe low-level transport is not writable (for example, when a POST request is already running in HTTP long-polling mode) socket.volatile.emit(/* ... */); // the server may or may not receive it Copy "},{"title":"Event: 'connect'​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#event-connect","content":"Fired upon connection to the Namespace (including a successful reconnection). socket.on(&quot;connect&quot;, () =&gt; { // ... }); Copy caution Please note that you shouldn't register event handlers in the connect handler itself, as a new handler will be registered every time the Socket reconnects: // BAD socket.on(&quot;connect&quot;, () =&gt; { socket.on(&quot;data&quot;, () =&gt; { /* ... */ }); }); // GOOD socket.on(&quot;connect&quot;, () =&gt; { /* ... */ }); socket.on(&quot;data&quot;, () =&gt; { /* ... */ }); Copy "},{"title":"Event: 'disconnect'​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#event-disconnect","content":"reason &lt;string&gt;details &lt;DisconnectDetails&gt; Fired upon disconnection. The list of possible disconnection reasons: Reason\tDescriptionio server disconnect\tThe server has forcefully disconnected the socket with socket.disconnect() io client disconnect\tThe socket was manually disconnected using socket.disconnect() ping timeout\tThe server did not send a PING within the pingInterval + pingTimeout range transport close\tThe connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G) transport error\tThe connection has encountered an error (example: the server was killed during a HTTP long-polling cycle) In the first two cases (explicit disconnection), the client will not try to reconnect and you need to manually call socket.connect(). In all other cases, the client will wait for a small random delay and then try to reconnect: socket.on(&quot;disconnect&quot;, (reason) =&gt; { if (reason === &quot;io server disconnect&quot;) { // the disconnection was initiated by the server, you need to reconnect manually socket.connect(); } // else the socket will automatically try to reconnect }); Copy "},{"title":"Event: 'connect_error'​","type":1,"pageTitle":"Client API","url":"docs/v1/client-api/#event-connect_error","content":"connect_error &lt;Error&gt; error object Fired when a namespace middleware error occurs. socket.on(&quot;connect_error&quot;, (error) =&gt; { // ... }); Copy "},{"title":"Listening to events","type":0,"sectionRef":"#","url":"docs/v1/listening-to-events/","content":"","keywords":""},{"title":"EventEmitter methods​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#eventemitter-methods","content":"On the server-side, the Socket instance extends the Node.js EventEmitter class. On the client-side, the Socket instance uses the event emitter provided by the component-emitter library, which exposes a subset of the EventEmitter methods. "},{"title":"socket.on(eventName, listener)​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#socketoneventname-listener","content":"Adds the listener function to the end of the listeners array for the event named eventName. socket.on(&quot;details&quot;, (...args) =&gt; { // ... }); Copy "},{"title":"socket.once(eventName, listener)​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#socketonceeventname-listener","content":"Adds a one-time listener function for the event named eventName socket.once(&quot;details&quot;, (...args) =&gt; { // ... }); Copy "},{"title":"socket.off(eventName, listener)​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#socketoffeventname-listener","content":"Removes the specified listener from the listener array for the event named eventName. const listener = (...args) =&gt; { console.log(args); } socket.on(&quot;details&quot;, listener); // and then later... socket.off(&quot;details&quot;, listener); Copy "},{"title":"socket.removeAllListeners([eventName])​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#socketremovealllistenerseventname","content":"Removes all listeners, or those of the specified eventName. // for a specific event socket.removeAllListeners(&quot;details&quot;); // for all events socket.removeAllListeners(); Copy "},{"title":"Catch-all listeners​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#catch-all-listeners","content":"Since Socket.IO v3, a new API inspired from the EventEmitter2 library allows to declare catch-all listeners. This feature is available on both the client and the server. "},{"title":"socket.onAny(listener)​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#socketonanylistener","content":"Adds a listener that will be fired when any event is emitted. socket.onAny((eventName, ...args) =&gt; { // ... }); Copy "},{"title":"socket.prependAny(listener)​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#socketprependanylistener","content":"Adds a listener that will be fired when any event is emitted. The listener is added to the beginning of the listeners array. socket.prependAny((eventName, ...args) =&gt; { // ... }); Copy "},{"title":"socket.offAny([listener])​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#socketoffanylistener","content":"Removes all catch-all listeners, or the given listener. const listener = (eventName, ...args) =&gt; { console.log(eventName, args); } socket.onAny(listener); // and then later... socket.offAny(listener); // or all listeners socket.offAny(); Copy "},{"title":"Validation​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#validation","content":"The validation of the event arguments is out of the scope of the Socket.IO library. There are many packages in the JS ecosystem which cover this use case, among them: joiajvvalidatorjs Example with joi and acknowledgements: const Joi = require(&quot;joi&quot;); const userSchema = Joi.object({ username: Joi.string().max(30).required(), email: Joi.string().email().required() }); io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;create user&quot;, (payload, callback) =&gt; { if (typeof callback !== &quot;function&quot;) { // not an acknowledgement return socket.disconnect(); } const { error, value } = userSchema.validate(payload); if (error) { return callback({ status: &quot;KO&quot;, error }); } // do something with the value, and then callback({ status: &quot;OK&quot; }); }); }); Copy "},{"title":"Error handling​","type":1,"pageTitle":"Listening to events","url":"docs/v1/listening-to-events/#error-handling","content":"There is currently no built-in error handling in the Socket.IO library, which means you must catch any error that could be thrown in a listener. io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;list items&quot;, async (callback) =&gt; { try { const items = await findItems(); callback({ status: &quot;OK&quot;, items }); } catch (e) { callback({ status: &quot;NOK&quot; }); } }); }); Copy On the server-side, using EventEmitter.captureRejections = true (experimental, see here) might be interesting too, depending on your use case. require(&quot;events&quot;).captureRejections = true; io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;list products&quot;, async () =&gt; { const products = await findProducts(); socket.emit(&quot;products&quot;, products); }); socket[Symbol.for('nodejs.rejection')] = (err) =&gt; { socket.emit(&quot;error&quot;, err); }; }); Copy "},{"title":"Middlewares","type":0,"sectionRef":"#","url":"docs/v1/middlewares/","content":"","keywords":""},{"title":"Registering a middleware​","type":1,"pageTitle":"Middlewares","url":"docs/v1/middlewares/#registering-a-middleware","content":"A middleware function has access to the Socket instance and to the next registered middleware function. io.use((socket, next) =&gt; { if (isValid(socket.request)) { next(); } else { next(new Error(&quot;invalid&quot;)); } }); Copy You can register several middleware functions, and they will be executed sequentially: io.use((socket, next) =&gt; { next(); }); io.use((socket, next) =&gt; { next(new Error(&quot;thou shall not pass&quot;)); }); io.use((socket, next) =&gt; { // not executed, since the previous middleware has returned an error next(); }); Copy Please make sure to call next() in any case. Otherwise, the connection will be left hanging until it is closed after a given timeout. Important note: the Socket instance is not actually connected when the middleware gets executed, which means that no disconnect event will be emitted if the connection eventually fails. For example, if the client manually closes the connection: // server-side io.use((socket, next) =&gt; { setTimeout(() =&gt; { // next is called after the client disconnection next(); }, 1000); socket.on(&quot;disconnect&quot;, () =&gt; { // not triggered }); }); io.on(&quot;connection&quot;, (socket) =&gt; { // not triggered }); // client-side const socket = io(); setTimeout(() =&gt; { socket.disconnect(); }, 500); Copy "},{"title":"Sending credentials​","type":1,"pageTitle":"Middlewares","url":"docs/v1/middlewares/#sending-credentials","content":"The client can send credentials with the auth option: // plain object const socket = io({ auth: { token: &quot;abc&quot; } }); // or with a function const socket = io({ auth: (cb) =&gt; { cb({ token: &quot;abc&quot; }); } }); Copy Those credentials can be accessed in the handshake object on the server-side: io.use((socket, next) =&gt; { const token = socket.handshake.auth.token; // ... }); Copy "},{"title":"Handling middleware error​","type":1,"pageTitle":"Middlewares","url":"docs/v1/middlewares/#handling-middleware-error","content":"If the next method is called with an Error object, the connection will be refused and the client will receive an connect_error event. // client-side socket.on(&quot;connect_error&quot;, (err) =&gt; { console.log(err.message); // prints the message associated with the error }); Copy You can attach additional details to the Error object: // server-side io.use((socket, next) =&gt; { const err = new Error(&quot;not authorized&quot;); err.data = { content: &quot;Please retry later&quot; }; // additional details next(err); }); // client-side socket.on(&quot;connect_error&quot;, (err) =&gt; { console.log(err instanceof Error); // true console.log(err.message); // not authorized console.log(err.data); // { content: &quot;Please retry later&quot; } }); Copy "},{"title":"Compatibility with Express middleware​","type":1,"pageTitle":"Middlewares","url":"docs/v1/middlewares/#compatibility-with-express-middleware","content":"Most existing Express middleware modules should be compatible with Socket.IO, you just need a little wrapper function to make the method signatures match: const wrap = middleware =&gt; (socket, next) =&gt; middleware(socket.request, {}, next); Copy The middleware functions that end the request-response cycle and do not call next() will not work though. Example with express-session: const session = require(&quot;express-session&quot;); io.use(wrap(session({ secret: &quot;cats&quot; }))); io.on(&quot;connection&quot;, (socket) =&gt; { const session = socket.request.session; }); Copy Example with Passport: const session = require(&quot;express-session&quot;); const passport = require(&quot;passport&quot;); io.use(wrap(session({ secret: &quot;cats&quot; }))); io.use(wrap(passport.initialize())); io.use(wrap(passport.session())); io.use((socket, next) =&gt; { if (socket.request.user) { next(); } else { next(new Error(&quot;unauthorized&quot;)) } }); Copy A complete example with Passport can be found here. "},{"title":"Client options","type":0,"sectionRef":"#","url":"docs/v1/client-options/","content":"","keywords":""},{"title":"IO factory options​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#io-factory-options","content":""},{"title":"forceNew​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#forcenew","content":"Default value: false Whether to create a new Manager instance. A Manager instance is in charge of the low-level connection to the server (established with HTTP long-polling or WebSocket). It handles the reconnection logic. A Socket instance is the interface which is used to sends events to — and receive events from — the server. It belongs to a given namespace. A single Manager can be attached to several Socket instances. The following example will reuse the same Manager instance for the 3 Socket instances (one single WebSocket connection): const socket = io(&quot;https://example.com&quot;); // the main namespace const productSocket = io(&quot;https://example.com/product&quot;); // the &quot;product&quot; namespace const orderSocket = io(&quot;https://example.com/order&quot;); // the &quot;order&quot; namespace Copy The following example will create 3 different Manager instances (and thus 3 distinct WebSocket connections): const socket = io(&quot;https://example.com&quot;); // the main namespace const productSocket = io(&quot;https://example.com/product&quot;, { forceNew: true }); // the &quot;product&quot; namespace const orderSocket = io(&quot;https://example.com/order&quot;, { forceNew: true }); // the &quot;order&quot; namespace Copy Reusing an existing namespace will also create a new Manager each time: const socket1 = io(); // 1st manager const socket2 = io(); // 2nd manager const socket3 = io(&quot;/admin&quot;); // reuse the 1st manager const socket4 = io(&quot;/admin&quot;); // 3rd manager Copy "},{"title":"multiplex​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#multiplex","content":"Default value: true The opposite of forceNew: whether to reuse an existing Manager instance. const socket = io(); // 1st manager const adminSocket = io(&quot;/admin&quot;, { multiplex: false }); // 2nd manager Copy "},{"title":"Low-level engine options​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#low-level-engine-options","content":"info These settings will be shared by all Socket instances attached to the same Manager. "},{"title":"transports​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#transports","content":"Default value: [&quot;polling&quot;, &quot;websocket&quot;] The low-level connection to the Socket.IO server can either be established with: HTTP long-polling: successive HTTP requests (POST for writing, GET for reading)WebSocket The following example disables the HTTP long-polling transport: const socket = io(&quot;https://example.com&quot;, { transports: [&quot;websocket&quot;] }); Copy Note: in that case, sticky sessions are not required on the server side (more information here). By default, the HTTP long-polling connection is established first, and then an upgrade to WebSocket is attempted (explanation here). You can use WebSocket first with: const socket = io(&quot;https://example.com&quot;, { transports: [&quot;websocket&quot;, &quot;polling&quot;] // use WebSocket first, if available }); socket.on(&quot;connect_error&quot;, () =&gt; { // revert to classic upgrade socket.io.opts.transports = [&quot;polling&quot;, &quot;websocket&quot;]; }); Copy One possible downside is that the validity of your CORS configuration will only be checked if the WebSocket connection fails to be established. "},{"title":"upgrade​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#upgrade","content":"Default value: true Whether the client should try to upgrade the transport from HTTP long-polling to something better. "},{"title":"rememberUpgrade​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#rememberupgrade","content":"Default value: false If true and if the previous WebSocket connection to the server succeeded, the connection attempt will bypass the normal upgrade process and will initially try WebSocket. A connection attempt following a transport error will use the normal upgrade process. It is recommended you turn this on only when using SSL/TLS connections, or if you know that your network does not block websockets. "},{"title":"path​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#path","content":"Default value: /socket.io/ It is the name of the path that is captured on the server side. caution The server and the client values must match (unless you are using a path-rewriting proxy in between). Client import { io } from &quot;socket.io-client&quot;; const socket = io(&quot;https://example.com&quot;, { path: &quot;/my-custom-path/&quot; }); Copy Server import { createServer } from &quot;http&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer(); const io = new Server(httpServer, { path: &quot;/my-custom-path/&quot; }); Copy Please note that this is different from the path in the URI, which represents the Namespace. Example: import { io } from &quot;socket.io-client&quot;; const socket = io(&quot;https://example.com/order&quot;, { path: &quot;/my-custom-path/&quot; }); Copy the Socket instance is attached to the &quot;order&quot; Namespacethe HTTP requests will look like: GET https://example.com/my-custom-path/?EIO=4&amp;transport=polling&amp;t=ML4jUwU "},{"title":"query​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#query","content":"Default value: - Additional query parameters (then found in socket.handshake.query object on the server-side). Example: Client import { io } from &quot;socket.io-client&quot;; const socket = io({ query: { x: 42 } }); Copy Server io.on(&quot;connection&quot;, (socket) =&gt; { console.log(socket.handshake.query); // prints { x: &quot;42&quot;, EIO: &quot;4&quot;, transport: &quot;polling&quot; } }); Copy The query parameters cannot be updated for the duration of the session, so changing the query on the client-side will only be effective when the current session gets closed and a new one is created: socket.io.on(&quot;reconnect_attempt&quot;, () =&gt; { socket.io.opts.query.x++; }); Copy Note: the following query parameters are reserved and can't be used in your application: EIO: the version of the protocol (currently, &quot;4&quot;)transport: the transport name (&quot;polling&quot; or &quot;websocket&quot;)sid: the session IDj: if the transport is polling but a JSONP response is requiredt: a hashed-timestamp used for cache-busting "},{"title":"extraHeaders​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#extraheaders","content":"Default value: - Additional headers (then found in socket.handshake.headers object on the server-side). Example: Client import { io } from &quot;socket.io-client&quot;; const socket = io({ extraHeaders: { &quot;my-custom-header&quot;: &quot;1234&quot; } }); Copy Server io.on(&quot;connection&quot;, (socket) =&gt; { console.log(socket.handshake.headers); // an object containing &quot;my-custom-header&quot;: &quot;1234&quot; }); Copy caution In a browser environment, the extraHeaders option will be ignored if you only enable the WebSocket transport, since the WebSocket API in the browser does not allow providing custom headers. import { io } from &quot;socket.io-client&quot;; const socket = io({ transports: [&quot;websocket&quot;], extraHeaders: { &quot;my-custom-header&quot;: &quot;1234&quot; // ignored } }); Copy This will work in Node.js or in React-Native though. Documentation: WebSocket API "},{"title":"withCredentials​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#withcredentials","content":"Default value: false Whether or not cross-site requests should made using credentials such as cookies, authorization headers or TLS client certificates. Setting withCredentials has no effect on same-site requests. import { io } from &quot;socket.io-client&quot;; const socket = io(&quot;https://my-backend.com&quot;, { withCredentials: true }); Copy The server needs to send the right Access-Control-Allow-* headers to allow the connection: import { createServer } from &quot;http&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer(); const io = new Server(httpServer, { cors: { origin: &quot;https://my-frontend.com&quot;, credentials: true } }); Copy caution You cannot use origin: * when setting withCredentials to true. This will trigger the following error: Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at ‘.../socket.io/?EIO=4&amp;transport=polling&amp;t=NvQfU77’. (Reason: Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*’) Documentation: XMLHttpRequest.withCredentialsHandling CORS "},{"title":"forceBase64​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#forcebase64","content":"Default value: false Whether to force base64 encoding for binary content sent over WebSocket (always enabled for HTTP long-polling). "},{"title":"timestampRequests​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#timestamprequests","content":"Default value: true Whether to add the timestamp query param to each request (for cache busting). "},{"title":"timestampParam​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#timestampparam","content":"Default value: &quot;t&quot; The name of the query parameter to use as our timestamp key. "},{"title":"closeOnBeforeunload​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#closeonbeforeunload","content":"Added in v4.1.0 Default value: true Whether to (silently) close the connection when the beforeunload event is emitted in the browser. With closeOnBeforeunload set to false, a disconnect event will be emitted by the Socket instance when the user reloads the page on Firefox (but not on Chrome or Safari). With closeOnBeforeunload set to true, all browsers will have the same behavior (no disconnect event when reloading the page). But this might cause issues if you use the beforeunload event in your application. "},{"title":"protocols​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#protocols","content":"Added in v2.0.0 Default value: - Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified protocol). import { io } from &quot;socket.io-client&quot;; const socket = io({ transports: [&quot;websocket&quot;], protocols: [&quot;my-protocol-v1&quot;] }); Copy Server: io.on(&quot;connection&quot;, (socket) =&gt; { const transport = socket.conn.transport; console.log(transport.socket.protocol); // prints &quot;my-protocol-v1&quot; }); Copy References: https://datatracker.ietf.org/doc/html/rfc6455#section-1.9https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket "},{"title":"autoUnref​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#autounref","content":"Added in v4.0.0 Default value: false With autoUnref set to true, the Socket.IO client will allow the program to exit if there is no other active timer/TCP socket in the event system (even if the client is connected): import { io } from &quot;socket.io-client&quot;; const socket = io({ autoUnref: true }); Copy See also: https://nodejs.org/api/timers.html#timeoutunref "},{"title":"Node.js-specific options​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#nodejs-specific-options","content":"The following options are supported: agentpfxkeypassphrasecertcaciphersrejectUnauthorized Please refer to the Node.js documentation: tls.connect(options[, callback])tls.createSecureContext([options]) Example with a self-signed certificate: Client import { readFileSync } from &quot;fs&quot;; import { io } from &quot;socket.io-client&quot;; const socket = io(&quot;https://example.com&quot;, { ca: readFileSync(&quot;./cert.pem&quot;) }); Copy Server import { readFileSync } from &quot;fs&quot;; import { createServer } from &quot;https&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer({ cert: readFileSync(&quot;./cert.pem&quot;), key: readFileSync(&quot;./key.pem&quot;) }); const io = new Server(httpServer); Copy Example with client-certificate authentication: Client import { readFileSync } from &quot;fs&quot;; import { io } from &quot;socket.io-client&quot;; const socket = io(&quot;https://example.com&quot;, { ca: readFileSync(&quot;./server-cert.pem&quot;), cert: readFileSync(&quot;./client-cert.pem&quot;), key: readFileSync(&quot;./client-key.pem&quot;), }); Copy Server import { readFileSync } from &quot;fs&quot;; import { createServer } from &quot;https&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer({ cert: readFileSync(&quot;./server-cert.pem&quot;), key: readFileSync(&quot;./server-key.pem&quot;), requestCert: true, ca: [ readFileSync(&quot;client-cert.pem&quot;) ] }); const io = new Server(httpServer); Copy caution rejectUnauthorized is a Node.js-only option, it will not bypass the security check in the browser: "},{"title":"Manager options​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#manager-options","content":"info These settings will be shared by all Socket instances attached to the same Manager. "},{"title":"reconnection​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#reconnection","content":"Default value: true Whether reconnection is enabled or not. If set to false, you need to manually reconnect: import { io } from &quot;socket.io-client&quot;; const socket = io({ reconnection: false }); const tryReconnect = () =&gt; { setTimeout(() =&gt; { socket.io.open((err) =&gt; { if (err) { tryReconnect(); } }); }, 2000); } socket.io.on(&quot;close&quot;, tryReconnect); Copy "},{"title":"reconnectionAttempts​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#reconnectionattempts","content":"Default value: Infinity The number of reconnection attempts before giving up. "},{"title":"reconnectionDelay​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#reconnectiondelay","content":"Default value: 1000 The initial delay before reconnection in milliseconds (affected by the randomizationFactor value). "},{"title":"reconnectionDelayMax​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#reconnectiondelaymax","content":"Default value: 5000 The maximum delay between two reconnection attempts. Each attempt increases the reconnection delay by 2x. "},{"title":"randomizationFactor​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#randomizationfactor","content":"Default value: 0.5 The randomization factor used when reconnecting (so that the clients do not reconnect at the exact same time after a server crash, for example). Example with the default values: 1st reconnection attempt happens between 500 and 1500 ms (1000 * 2^0 * (&lt;something between -0.5 and 1.5&gt;))2nd reconnection attempt happens between 1000 and 3000 ms (1000 * 2^1 * (&lt;something between -0.5 and 1.5&gt;))3rd reconnection attempt happens between 2000 and 5000 ms (1000 * 2^2 * (&lt;something between -0.5 and 1.5&gt;))next reconnection attempts happen after 5000 ms "},{"title":"timeout​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#timeout","content":"Default value: 20000 The timeout in milliseconds for each connection attempt. "},{"title":"autoConnect​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#autoconnect","content":"Default value: true Whether to automatically connect upon creation. If set to false, you need to manually connect: import { io } from &quot;socket.io-client&quot;; const socket = io({ autoConnect: false }); socket.connect(); // or socket.io.open(); Copy "},{"title":"parser​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#parser","content":"Added in v2.2.0 Default value: require(&quot;socket.io-parser&quot;) The parser used to marshall/unmarshall packets. Please see here for more information. "},{"title":"Socket options​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#socket-options","content":"info These settings are specific to the given Socket instance. "},{"title":"auth​","type":1,"pageTitle":"Client options","url":"docs/v1/client-options/#auth","content":"Added in v3.0.0 Default value: - Credentials that are sent when accessing a namespace (see also here). Example: Client import { io } from &quot;socket.io-client&quot;; const socket = io({ auth: { token: &quot;abcd&quot; } }); // or with a function const socket = io({ auth: (cb) =&gt; { cb({ token: localStorage.token }) } }); Copy Server io.on(&quot;connection&quot;, (socket) =&gt; { console.log(socket.handshake.auth); // prints { token: &quot;abcd&quot; } }); Copy You can update the auth map when the access to the Namespace is denied: socket.on(&quot;connect_error&quot;, (err) =&gt; { if (err.message === &quot;invalid credentials&quot;) { socket.auth.token = &quot;efgh&quot;; socket.connect(); } }); Copy Or manually force the Socket instance to reconnect: socket.auth.token = &quot;efgh&quot;; socket.disconnect().connect(); Copy "},{"title":"Usage with bundlers","type":0,"sectionRef":"#","url":"docs/v1/server-with-bundlers/","content":"","keywords":""},{"title":"Webpack 5​","type":1,"pageTitle":"Usage with bundlers","url":"docs/v1/server-with-bundlers/#webpack-5","content":""},{"title":"Without serving the client files​","type":1,"pageTitle":"Usage with bundlers","url":"docs/v1/server-with-bundlers/#without-serving-the-client-files","content":"Installation: npm install -D webpack webpack-cli socket.io bufferutil utf-8-validate Copy index.js const { Server } = require(&quot;socket.io&quot;); const io = new Server({ serveClient: false }); io.on(&quot;connection&quot;, socket =&gt; { console.log(`connect ${socket.id}`); socket.on(&quot;disconnect&quot;, (reason) =&gt; { console.log(`disconnect ${socket.id} due to ${reason}`); }); }); io.listen(3000); Copy webpack.config.js const path = require(&quot;path&quot;); module.exports = { entry: &quot;./index.js&quot;, target: &quot;node&quot;, mode: &quot;production&quot;, output: { path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;index.js&quot;, } }; Copy Note: bufferutil and utf-8-validate are two optional dependencies from the ws package. You can also set them as &quot;external&quot; with: const path = require(&quot;path&quot;); module.exports = { entry: &quot;./index.js&quot;, target: &quot;node&quot;, mode: &quot;production&quot;, output: { path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;index.js&quot;, }, externals: { bufferutil: &quot;bufferutil&quot;, &quot;utf-8-validate&quot;: &quot;utf-8-validate&quot;, }, }; Copy Documentation: https://webpack.js.org/configuration/externals/ "},{"title":"Including serving the client files​","type":1,"pageTitle":"Usage with bundlers","url":"docs/v1/server-with-bundlers/#including-serving-the-client-files","content":"In that case, we'll have to use Asset modules and override the sendFile function of the Socket.IO server: index.js const { Server } = require(&quot;socket.io&quot;); const clientFile = require(&quot;./node_modules/socket.io/client-dist/socket.io.min?raw&quot;); const clientMap = require(&quot;./node_modules/socket.io/client-dist/socket.io.min.js.map?raw&quot;); Server.sendFile = (filename, req, res) =&gt; { res.end(filename.endsWith(&quot;.map&quot;) ? clientMap : clientFile); }; const io = new Server(); io.on(&quot;connection&quot;, socket =&gt; { console.log(`connect ${socket.id}`); socket.on(&quot;disconnect&quot;, (reason) =&gt; { console.log(`disconnect ${socket.id} due to ${reason}`); }); }); io.listen(3000); Copy webpack.config.js const path = require(&quot;path&quot;); module.exports = { entry: &quot;./index.js&quot;, target: &quot;node&quot;, mode: &quot;production&quot;, output: { path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;index.js&quot;, }, module: { rules: [ { resourceQuery: /raw/, type: &quot;asset/source&quot;, }, ], }, }; Copy "},{"title":"Server options","type":0,"sectionRef":"#","url":"docs/v1/server-options/","content":"","keywords":""},{"title":"Socket.IO server options​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#socketio-server-options","content":""},{"title":"path​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#path","content":"Default value: /socket.io/ It is the name of the path that is captured on the server side. caution The server and the client values must match (unless you are using a path-rewriting proxy in between). Server import { createServer } from &quot;http&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer(); const io = new Server(httpServer, { path: &quot;/my-custom-path/&quot; }); Copy Client import { io } from &quot;socket.io-client&quot;; const socket = io(&quot;https://example.com&quot;, { path: &quot;/my-custom-path/&quot; }); Copy "},{"title":"serveClient​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#serveclient","content":"Default value: true Whether to serve the client files. If true, the different bundles will be served at the following location: &lt;url&gt;/socket.io/socket.io.js&lt;url&gt;/socket.io/socket.io.min.js&lt;url&gt;/socket.io/socket.io.msgpack.min.js (including their associated source maps) See also here. "},{"title":"adapter​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#adapter","content":"Default value: require(&quot;socket.io-adapter&quot;) (in-memory adapter, whose source code can be found here) The &quot;Adapter&quot; to use. Example with the Redis adapter: CommonJSES modulesTypeScript const { Server } = require(&quot;socket.io&quot;); const { createAdapter } = require(&quot;@socket.io/redis-adapter&quot;); const { createClient } = require(&quot;redis&quot;); const pubClient = createClient({ host: &quot;localhost&quot;, port: 6379 }); const subClient = pubClient.duplicate(); const io = new Server({ adapter: createAdapter(pubClient, subClient) }); io.listen(3000); Copy "},{"title":"parser​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#parser","content":"Default value: socket.io-parser The parser to use. Please see the documentation here. "},{"title":"connectTimeout​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#connecttimeout","content":"Default value: 45000 The number of ms before disconnecting a client that has not successfully joined a namespace. "},{"title":"Low-level engine options​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#low-level-engine-options","content":""},{"title":"pingTimeout​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#pingtimeout","content":"Default value: 20000 This value is used in the heartbeat mechanism, which periodically checks if the connection is still alive between the server and the client. The server sends a ping, and if the client does not answer with a pong within pingTimeout ms, the server considers that the connection is closed. Similarly, if the client does not receive a ping from the server within pingInterval + pingTimeout ms, the client also considers that the connection is closed. In both cases, the disconnection reason will be: ping timeout socket.on(&quot;disconnect&quot;, (reason) =&gt; { console.log(reason); // &quot;ping timeout&quot; }); Copy Note: the default value might be a bit low if you need to send big files in your application. Please increase it if that's the case: const io = new Server(httpServer, { pingTimeout: 30000 }); Copy "},{"title":"pingInterval​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#pinginterval","content":"Default value: 25000 See above. "},{"title":"upgradeTimeout​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#upgradetimeout","content":"Default value: 10000 This is the delay in milliseconds before an uncompleted transport upgrade is cancelled. "},{"title":"maxHttpBufferSize​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#maxhttpbuffersize","content":"Default value: 1e6 (1 MB) This defines how many bytes a single message can be, before closing the socket. You may increase or decrease this value depending on your needs. const io = new Server(httpServer, { maxHttpBufferSize: 1e8 }); Copy It matches the maxPayload option of the ws package. "},{"title":"allowRequest​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#allowrequest","content":"Default: - A function that receives a given handshake or upgrade request as its first parameter, and can decide whether to continue or not. Example: const io = new Server(httpServer, { allowRequest: (req, callback) =&gt; { const isOriginValid = check(req); callback(null, isOriginValid); } }); Copy This can also be used in conjunction with the initial_headers event, to send a cookie to the client: import { serialize } from &quot;cookie&quot;; const io = new Server(httpServer, { allowRequest: async (req, callback) =&gt; { const session = await fetchSession(req); req.session = session; callback(null, true); } }); io.engine.on(&quot;initial_headers&quot;, (headers, req) =&gt; { if (req.session) { headers[&quot;set-cookie&quot;] = serialize(&quot;sid&quot;, req.session.id, { sameSite: &quot;strict&quot; }); } }); Copy See also: how to use with express-sessionhow to deal with cookies "},{"title":"transports​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#transports","content":"Default value: [&quot;polling&quot;, &quot;websocket&quot;] The low-level transports that are allowed on the server-side. See also: client-side transports "},{"title":"allowUpgrades​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#allowupgrades","content":"Default value: true Whether to allow transport upgrades. "},{"title":"perMessageDeflate​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#permessagedeflate","content":"History Version\tChangesv3.0.0\tThe permessage-deflate extension is now disabled by default. v1.4.0\tFirst implementation. Default value: false Whether to enable the permessage-deflate extension for the WebSocket transport. This extension is known to add a significant overhead in terms of performance and memory consumption, so we suggest to only enable it if it is really needed. Please note that if perMessageDeflate is set to false (which is the default), the compress flag used when emitting (socket.compress(true).emit(...)) will be ignored when the connection is established with WebSockets, as the permessage-deflate extension cannot be enabled on a per-message basis. All options from the ws module are supported: const io = new Server(httpServer, { perMessageDeflate: { threshold: 2048, // defaults to 1024 zlibDeflateOptions: { chunkSize: 8 * 1024, // defaults to 16 * 1024 }, zlibInflateOptions: { windowBits: 14, // defaults to 15 memLevel: 7, // defaults to 8 }, clientNoContextTakeover: true, // defaults to negotiated value. serverNoContextTakeover: true, // defaults to negotiated value. serverMaxWindowBits: 10, // defaults to negotiated value. concurrencyLimit: 20, // defaults to 10 } }); Copy "},{"title":"httpCompression​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#httpcompression","content":"Added in v1.4.0 Default value: true Whether to enable the compression for the HTTP long-polling transport. Please note that if httpCompression is set to false, the compress flag used when emitting (socket.compress(true).emit(...)) will be ignored when the connection is established with HTTP long-polling requests. All options from the Node.js zlib module are supported. Example: const io = new Server(httpServer, { httpCompression: { // Engine.IO options threshold: 2048, // defaults to 1024 // Node.js zlib options chunkSize: 8 * 1024, // defaults to 16 * 1024 windowBits: 14, // defaults to 15 memLevel: 7, // defaults to 8 } }); Copy "},{"title":"wsEngine​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#wsengine","content":"Default value: require(&quot;ws&quot;).Server (source code can be found here) The WebSocket server implementation to use. Please see the documentation here. Example: const io = new Server(httpServer, { wsEngine: require(&quot;eiows&quot;).Server }); Copy "},{"title":"cors​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#cors","content":"Default value: - The list of options that will be forwarded to the cors module. More information can be found here. Example: const io = new Server(httpServer, { cors: { origin: [&quot;https://example.com&quot;, &quot;https://dev.example.com&quot;], allowedHeaders: [&quot;my-custom-header&quot;], credentials: true } }); Copy "},{"title":"cookie​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#cookie","content":"Default value: - The list of options that will be forwarded to the cookie module. Available options: domainencodeexpireshttpOnlymaxAgepathsameSitesecure Example: import { Server } from &quot;socket.io&quot;; const io = new Server(httpServer, { cookie: { name: &quot;my-cookie&quot;, httpOnly: true, sameSite: &quot;strict&quot;, maxAge: 86400 } }); Copy info Since Socket.IO v3, there is no cookie sent by default anymore (reference). "},{"title":"allowEIO3​","type":1,"pageTitle":"Server options","url":"docs/v1/server-options/#alloweio3","content":"Default value: false Whether to enable compatibility with Socket.IO v2 clients. See also: Migrating from 2.x to 3.0 Example: const io = new Server(httpServer, { allowEIO3: true // false by default }); Copy "},{"title":"The Socket instance (server-side)","type":0,"sectionRef":"#","url":"docs/v1/server-socket-instance/","content":"","keywords":""},{"title":"Socket#id​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#socketid","content":"Each new connection is assigned a random 20-characters identifier. This identifier is synced with the value on the client-side. // server-side io.on(&quot;connection&quot;, (socket) =&gt; { console.log(socket.id); // ojIckSD2jqNzOqIrAGzL }); // client-side socket.on(&quot;connect&quot;, () =&gt; { console.log(socket.id); // ojIckSD2jqNzOqIrAGzL }); Copy Upon creation, the Socket joins the room identified by its own id, which means you can use it for private messaging: io.on(&quot;connection&quot;, socket =&gt; { socket.on(&quot;private message&quot;, (anotherSocketId, msg) =&gt; { socket.to(anotherSocketId).emit(&quot;private message&quot;, socket.id, msg); }); }); Copy Note: you can't overwrite this identifier, as it is used in several parts of the Socket.IO codebase. "},{"title":"Socket#handshake​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#sockethandshake","content":"This object contains some details about the handshake that happens at the beginning of the Socket.IO session. { headers: /* the headers of the initial request */ query: /* the query params of the initial request */ auth: /* the authentication payload */ time: /* the date of creation (as string) */ issued: /* the date of creation (unix timestamp) */ url: /* the request URL string */ address: /* the ip of the client */ xdomain: /* whether the connection is cross-domain */ secure: /* whether the connection is secure */ } Copy Example: { &quot;headers&quot;: { &quot;user-agent&quot;: &quot;xxxx&quot;, &quot;accept&quot;: &quot;*/*&quot;, &quot;host&quot;: &quot;example.com&quot;, &quot;connection&quot;: &quot;close&quot; }, &quot;query&quot;: { &quot;EIO&quot;: &quot;4&quot;, &quot;transport&quot;: &quot;polling&quot;, &quot;t&quot;: &quot;NNjNltH&quot; }, &quot;auth&quot;: { &quot;token&quot;: &quot;123&quot; }, &quot;time&quot;: &quot;Sun Nov 22 2020 01:33:46 GMT+0100 (Central European Standard Time)&quot;, &quot;issued&quot;: 1606005226969, &quot;url&quot;: &quot;/socket.io/?EIO=4&amp;transport=polling&amp;t=NNjNltH&quot;, &quot;address&quot;: &quot;::ffff:1.2.3.4&quot;, &quot;xdomain&quot;: false, &quot;secure&quot;: true } Copy "},{"title":"Socket#rooms​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#socketrooms","content":"This is a reference to the rooms the Socket is currently in. io.on(&quot;connection&quot;, (socket) =&gt; { console.log(socket.rooms); // Set { &lt;socket.id&gt; } socket.join(&quot;room1&quot;); console.log(socket.rooms); // Set { &lt;socket.id&gt;, &quot;room1&quot; } }); Copy "},{"title":"Socket#data​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#socketdata","content":"An arbitrary object that can be used in conjunction with the fetchSockets() utility method: // server A io.on(&quot;connection&quot;, (socket) =&gt; { socket.data.username = &quot;alice&quot;; }); // server B const sockets = await io.fetchSockets(); console.log(sockets[0].data.username); // &quot;alice&quot; Copy More information here. "},{"title":"Socket#conn​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#socketconn","content":"A reference to the underlying Engine.IO socket (see here). io.on(&quot;connection&quot;, (socket) =&gt; { console.log(&quot;initial transport&quot;, socket.conn.transport.name); // prints &quot;polling&quot; socket.conn.once(&quot;upgrade&quot;, () =&gt; { // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket) console.log(&quot;upgraded transport&quot;, socket.conn.transport.name); // prints &quot;websocket&quot; }); socket.conn.on(&quot;packet&quot;, ({ type, data }) =&gt; { // called for each packet received }); socket.conn.on(&quot;packetCreate&quot;, ({ type, data }) =&gt; { // called for each packet sent }); socket.conn.on(&quot;drain&quot;, () =&gt; { // called when the write buffer is drained }); socket.conn.on(&quot;close&quot;, (reason) =&gt; { // called when the underlying connection is closed }); }); Copy "},{"title":"Additional attributes​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#additional-attributes","content":"As long as you do not overwrite any existing attribute, you can attach any attribute to the Socket instance and use it later: // in a middleware io.use(async (socket, next) =&gt; { try { const user = await fetchUser(socket); socket.user = user; } catch (e) { next(new Error(&quot;unknown user&quot;)); } }); io.on(&quot;connection&quot;, (socket) =&gt; { console.log(socket.user); // in a listener socket.on(&quot;set username&quot;, (username) =&gt; { socket.username = username; }); }); Copy "},{"title":"Socket middlewares​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#socket-middlewares","content":"Those middlewares looks a lot like the usual middlewares, except that they are called for each incoming packet: socket.use(([event, ...args], next) =&gt; { // do something with the packet (logging, authorization, rate limiting...) // do not forget to call next() at the end next(); }); Copy The next method can also be called with an error object. In that case, the event will not reach the registered event handlers and an error event will be emitted instead: io.on(&quot;connection&quot;, (socket) =&gt; { socket.use(([event, ...args], next) =&gt; { if (isUnauthorized(event)) { return next(new Error(&quot;unauthorized event&quot;)); } next(); }); socket.on(&quot;error&quot;, (err) =&gt; { if (err &amp;&amp; err.message === &quot;unauthorized event&quot;) { socket.disconnect(); } }); }); Copy Note: this feature only exists on the server-side. For the client-side, you might be interested in catch-all listeners. "},{"title":"Events​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#events","content":"On the server-side, the Socket instance emits two special events: disconnectdisconnecting "},{"title":"disconnect​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#disconnect","content":"This event is fired by the Socket instance upon disconnection. io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;disconnect&quot;, (reason) =&gt; { // ... }); }); Copy Here is the list of possible reasons: Reason\tDescriptionserver namespace disconnect\tThe socket was forcefully disconnected with socket.disconnect client namespace disconnect\tThe client has manually disconnected the socket using socket.disconnect() server shutting down\tThe server is, well, shutting down ping timeout\tThe client did not send a PONG packet in the pingTimeout delay transport close\tThe connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G) transport error\tThe connection has encountered an error "},{"title":"disconnecting​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#disconnecting","content":"This event is similar to disconnect but is fired a bit earlier, when the Socket#rooms set is not empty yet io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;disconnecting&quot;, (reason) =&gt; { for (const room of socket.rooms) { if (room !== socket.id) { socket.to(room).emit(&quot;user has left&quot;, socket.id); } } }); }); Copy Note: those events, along with connect, connect_error, newListener and removeListener, are special events that shouldn't be used in your application: // BAD, will throw an error socket.emit(&quot;disconnect&quot;); Copy "},{"title":"Complete API​","type":1,"pageTitle":"The Socket instance (server-side)","url":"docs/v1/server-socket-instance/#complete-api","content":"The complete API exposed by the Socket instance can be found here. "},{"title":"Troubleshooting connection issues","type":0,"sectionRef":"#","url":"docs/v1/troubleshooting-connection-issues/","content":"","keywords":""},{"title":"Problem: the socket is not able to connect​","type":1,"pageTitle":"Troubleshooting connection issues","url":"docs/v1/troubleshooting-connection-issues/#problem-the-socket-is-not-able-to-connect","content":"Possible explanations: You are trying to reach a plain WebSocket serverThe server is not reachableThe client is not compatible with the version of the serverThe server does not send the necessary CORS headersYou didn’t enable sticky sessions (in a multi server setup) You are trying to reach a plain WebSocket server​ As explained in the &quot;What Socket.IO is not&quot; section, the Socket.IO client is not a WebSocket implementation and thus will not be able to establish a connection with a WebSocket server, even with transports: [&quot;websocket&quot;]: const socket = io(&quot;ws://echo.websocket.org&quot;, { transports: [&quot;websocket&quot;] }); Copy The server is not reachable​ Please make sure the Socket.IO server is actually reachable at the given URL. You can test it with: curl &quot;&lt;the server URL&gt;/socket.io/?EIO=4&amp;transport=polling&quot; Copy which should return something like this: 0{&quot;sid&quot;:&quot;Lbo5JLzTotvW3g2LAAAA&quot;,&quot;upgrades&quot;:[&quot;websocket&quot;],&quot;pingInterval&quot;:25000,&quot;pingTimeout&quot;:20000} Copy If that's not the case, please check that the Socket.IO server is running, and that there is nothing in between that prevents the connection. The client is not compatible with the version of the server​ Here is the compatibility table for the JS client: JS Client version\tSocket.IO server version 1.x\t2.x\t3.x\t4.x 1.x\tYES\tNO\tNO\tNO 2.x\tNO\tYES\tYES1\tYES1 3.x\tNO\tNO\tYES\tYES 4.x\tNO\tNO\tYES\tYES [1] Yes, with allowEIO3: true Here is the compatibility table for the Java client: Java Client version\tSocket.IO server version 2.x\t3.x\t4.x 1.x\tYES\tYES1\tYES1 2.x\tNO\tYES\tYES [1] Yes, with allowEIO3: true Here is the compatibility table for the Swift client: Swift Client version\tSocket.IO server version 2.x\t3.x\t4.x v15.x\tYES\tYES1\tYES2 v16.x\tYES3\tYES\tYES [1] Yes, with allowEIO3: true (server) and .connectParams([&quot;EIO&quot;: &quot;3&quot;]) (client): SocketManager(socketURL: URL(string:&quot;http://localhost:8087/&quot;)!, config: [.connectParams([&quot;EIO&quot;: &quot;3&quot;])]) Copy [2] Yes, allowEIO3: true (server) [3] Yes, with .version(.two) (client): SocketManager(socketURL: URL(string:&quot;http://localhost:8087/&quot;)!, config: [.version(.two)]) Copy The server does not send the necessary CORS headers​ If you see the following error in your console: Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at ... Copy It probably means that: either you are not actually reaching the Socket.IO server (see above)or you didn't enable Cross-Origin Resource Sharing (CORS) on the server-side. Please see the documentation here. You didn't enable sticky sessions (in a multi server setup)​ When scaling to multiple Socket.IO servers, you need to make sure that all the requests of a given Socket.IO session reach the same Socket.IO server. The explanation can be found here. Failure to do so will result in HTTP 400 responses with the code: {&quot;code&quot;:1,&quot;message&quot;:&quot;Session ID unknown&quot;} Please see the documentation here. "},{"title":"Problem: the socket gets disconnected​","type":1,"pageTitle":"Troubleshooting connection issues","url":"docs/v1/troubleshooting-connection-issues/#problem-the-socket-gets-disconnected","content":"First and foremost, please note that disconnections are common and expected, even on a stable Internet connection: anything between the user and the Socket.IO server may encounter a temporary failure or be restartedthe server itself may be killed as part of an autoscaling policythe user may lose connection or switch from WiFi to 4G, in case of a mobile browserthe browser itself may freeze an inactive tab That being said, the Socket.IO client will always try to reconnect, unless specifically told otherwise. Possible explanations for a disconnection: The browser tab was minimized and heartbeat has failedThe client is not compatible with the version of the serverYou are trying to send a huge payload The browser tab was minimized and heartbeat has failed​ When a browser tab is not in focus, some browsers (like Chrome) throttle JavaScript timers, which could lead to a disconnection by ping timeout in Socket.IO v2, as the heartbeat mechanism relied on setTimeout function on the client side. As a workaround, you can increase the pingTimeout value on the server side: const io = new Server({ pingTimeout: 60000 }); Copy Please note that upgrading to Socket.IO v4 (at least socket.io-client@4.1.3, due to this) should prevent this kind of issues, as the heartbeat mechanism has been reversed (the server now sends PING packets). The client is not compatible with the version of the server​ Since the format of the packets sent over the WebSocket transport is similar in v2 and v3/v4, you might be able to connect with an incompatible client (see above), but the connection will eventually be closed after a given delay. So if you are experiencing a regular disconnection after 30 seconds (which was the sum of the values of pingTimeout and pingInterval in Socket.IO v2), this is certainly due to a version incompatibility. You are trying to send a huge payload​ If you get disconnected while sending a huge payload, this may mean that you have reached the maxHttpBufferSize value, which defaults to 1 MB. Please adjust it according to your needs: const io = require(&quot;socket.io&quot;)(httpServer, { maxHttpBufferSize: 1e8 }); Copy A huge payload taking more time to upload than the value of the pingTimeout option can also trigger a disconnection (since the heartbeat mechanism fails during the upload). Please adjust it according to your needs: const io = require(&quot;socket.io&quot;)(httpServer, { pingTimeout: 60000 }); Copy "},{"title":"Problem: the socket is stuck in HTTP long-polling​","type":1,"pageTitle":"Troubleshooting connection issues","url":"docs/v1/troubleshooting-connection-issues/#problem-the-socket-is-stuck-in-http-long-polling","content":"In most cases, you should see something like this:  the Engine.IO handshake (contains the session ID — here, zBjrh...AAAK — that is used in subsequent requests)the Socket.IO handshake request (contains the value of the auth option)the Socket.IO handshake response (contains the Socket#id)the WebSocket connectionthe first HTTP long-polling request, which is closed once the WebSocket connection is established If you don't see a HTTP 101 Switching Protocols response for the 4th request, that means that something between the server and your browser is preventing the WebSocket connection. Please note that this is not necessarily blocking since the connection is still established with HTTP long-polling, but it is less efficient. You can get the name of the current transport with: Client-side socket.on(&quot;connect&quot;, () =&gt; { const transport = socket.io.engine.transport.name; // in most cases, &quot;polling&quot; socket.io.engine.on(&quot;upgrade&quot;, () =&gt; { const upgradedTransport = socket.io.engine.transport.name; // in most cases, &quot;websocket&quot; }); }); Copy Server-side io.on(&quot;connection&quot;, (socket) =&gt; { const transport = socket.conn.transport.name; // in most cases, &quot;polling&quot; socket.conn.on(&quot;upgrade&quot;, () =&gt; { const upgradedTransport = socket.conn.transport.name; // in most cases, &quot;websocket&quot; }); }); Copy Possible explanations: a proxy in front of your servers does not accept the WebSocket connection A proxy in front of your servers does not accept the WebSocket connection​ Please see the documentation here. "},{"title":"TypeScript","type":0,"sectionRef":"#","url":"docs/v1/typescript/","content":"","keywords":""},{"title":"Types for the server​","type":1,"pageTitle":"TypeScript","url":"docs/v1/typescript/#types-for-the-server","content":"First, declare some types: interface ServerToClientEvents { noArg: () =&gt; void; basicEmit: (a: number, b: string, c: Buffer) =&gt; void; withAck: (d: string, callback: (e: number) =&gt; void) =&gt; void; } interface ClientToServerEvents { hello: () =&gt; void; } interface InterServerEvents { ping: () =&gt; void; } interface SocketData { name: string; age: number; } Copy And use them when creating your server: const io = new Server&lt;ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData&gt;(); Copy Then, profit from the help of your IDE! The events declared in the ServerToClientEvents interface are used when sending and broadcasting events: io.on(&quot;connection&quot;, (socket) =&gt; { socket.emit(&quot;noArg&quot;); socket.emit(&quot;basicEmit&quot;, 1, &quot;2&quot;, Buffer.from([3])); socket.emit(&quot;withAck&quot;, &quot;4&quot;, (e) =&gt; { // e is inferred as number }); // works when broadcast to all io.emit(&quot;noArg&quot;); // works when broadcasting to a room io.to(&quot;room1&quot;).emit(&quot;basicEmit&quot;, 1, &quot;2&quot;, Buffer.from([3])); }); Copy The ones declared in the ClientToServerEvents interface are used when receiving events: io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;hello&quot;, () =&gt; { // ... }); }); Copy The ones declared in the InterServerEvents interface are used for inter-server communication (added in socket.io@4.1.0): io.serverSideEmit(&quot;ping&quot;); io.on(&quot;ping&quot;, () =&gt; { // ... }); Copy And finally, the SocketData type is used to type the socket.data attribute (added in socket.io@4.4.0): io.on(&quot;connection&quot;, (socket) =&gt; { socket.data.name = &quot;john&quot;; socket.data.age = 42; }); Copy caution These type hints do not replace proper validation/sanitization of the input. As usual, never trust user input. "},{"title":"Types for the client​","type":1,"pageTitle":"TypeScript","url":"docs/v1/typescript/#types-for-the-client","content":"On the client side, you can reuse the same ServerToClientEvents and ClientToServerEvents interfaces: import { io, Socket } from &quot;socket.io-client&quot;; // please note that the types are reversed const socket: Socket&lt;ServerToClientEvents, ClientToServerEvents&gt; = io(); Copy Similarly, the events declared in the ClientToServerEvents interface are used when sending events: socket.emit(&quot;hello&quot;); Copy And the ones declared in ServerToClientEvents are used when receiving events: socket.on(&quot;noArg&quot;, () =&gt; { // ... }); socket.on(&quot;basicEmit&quot;, (a, b, c) =&gt; { // a is inferred as number, b as string and c as buffer }); socket.on(&quot;withAck&quot;, (d, callback) =&gt; { // d is inferred as string and callback as a function that takes a number as argument }); Copy "},{"title":"The Server instance","type":0,"sectionRef":"#","url":"docs/v1/server-instance/","content":"","keywords":""},{"title":"Server#engine​","type":1,"pageTitle":"The Server instance","url":"docs/v1/server-instance/#serverengine","content":"A reference to the underlying Engine.IO server. It can be used to fetch the number of currently connected clients: const count = io.engine.clientsCount; // may or may not be similar to the count of Socket instances in the main namespace, depending on your usage const count2 = io.of(&quot;/&quot;).sockets.size; Copy Or to generate a custom session ID (the sid query parameter): const uuid = require(&quot;uuid&quot;); io.engine.generateId = (req) =&gt; { return uuid.v4(); // must be unique across all Socket.IO servers } Copy As of socket.io@4.1.0, the Engine.IO server emits three special events: initial_headers: will be emitted just before writing the response headers of the first HTTP request of the session (the handshake), allowing you to customize them. io.engine.on(&quot;initial_headers&quot;, (headers, req) =&gt; { headers[&quot;test&quot;] = &quot;123&quot;; headers[&quot;set-cookie&quot;] = &quot;mycookie=456&quot;; }); Copy headers: will be emitted just before writing the response headers of each HTTP request of the session (including the WebSocket upgrade), allowing you to customize them. io.engine.on(&quot;headers&quot;, (headers, req) =&gt; { headers[&quot;test&quot;] = &quot;789&quot;; }); Copy connection_error: will be emitted when a connection is abnormally closed io.engine.on(&quot;connection_error&quot;, (err) =&gt; { console.log(err.req); // the request object console.log(err.code); // the error code, for example 1 console.log(err.message); // the error message, for example &quot;Session ID unknown&quot; console.log(err.context); // some additional error context }); Copy Here is the list of possible error codes: Code\tMessage0\t&quot;Transport unknown&quot; 1\t&quot;Session ID unknown&quot; 2\t&quot;Bad handshake method&quot; 3\t&quot;Bad request&quot; 4\t&quot;Forbidden&quot; 5\t&quot;Unsupported protocol version&quot; "},{"title":"Utility methods​","type":1,"pageTitle":"The Server instance","url":"docs/v1/server-instance/#utility-methods","content":"Some utility methods were added in Socket.IO v4.0.0 to manage the Socket instances and their rooms: socketsJoin: makes the matching socket instances join the specified rooms̀socketsLeave: makes the matching socket instances leave the specified roomsdisconnectSockets: makes the matching socket instances disconnectfetchSockets: returns the matching socket instances The serverSideEmit method was added in Socket.IO v4.1.0. Those methods share the same semantics as broadcasting, and the same filters apply: io.of(&quot;/admin&quot;).in(&quot;room1&quot;).except(&quot;room2&quot;).local.disconnectSockets(); Copy Which makes all Socket instances of the &quot;admin&quot; namespace in the &quot;room1&quot; room (in(&quot;room1&quot;) or to(&quot;room1&quot;))except the ones in &quot;room2&quot; (except(&quot;room2&quot;))and only on the current Socket.IO server (local) disconnect. Please note that they are also compatible with the Redis adapter (starting with socket.io-redis@6.1.0), which means that they will work across Socket.IO servers. "},{"title":"socketsJoin​","type":1,"pageTitle":"The Server instance","url":"docs/v1/server-instance/#socketsjoin","content":"This method makes the matching Socket instances join the specified rooms: // make all Socket instances join the &quot;room1&quot; room io.socketsJoin(&quot;room1&quot;); // make all Socket instances in the &quot;room1&quot; room join the &quot;room2&quot; and &quot;room3&quot; rooms io.in(&quot;room1&quot;).socketsJoin([&quot;room2&quot;, &quot;room3&quot;]); // make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace join the &quot;room2&quot; room io.of(&quot;/admin&quot;).in(&quot;room1&quot;).socketsJoin(&quot;room2&quot;); // this also works with a single socket ID io.in(theSocketId).socketsJoin(&quot;room1&quot;); Copy "},{"title":"socketsLeave​","type":1,"pageTitle":"The Server instance","url":"docs/v1/server-instance/#socketsleave","content":"This method makes the matching Socket instances leave the specified rooms: // make all Socket instances leave the &quot;room1&quot; room io.socketsLeave(&quot;room1&quot;); // make all Socket instances in the &quot;room1&quot; room leave the &quot;room2&quot; and &quot;room3&quot; rooms io.in(&quot;room1&quot;).socketsLeave([&quot;room2&quot;, &quot;room3&quot;]); // make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace leave the &quot;room2&quot; room io.of(&quot;/admin&quot;).in(&quot;room1&quot;).socketsLeave(&quot;room2&quot;); // this also works with a single socket ID io.in(theSocketId).socketsLeave(&quot;room1&quot;); Copy "},{"title":"disconnectSockets​","type":1,"pageTitle":"The Server instance","url":"docs/v1/server-instance/#disconnectsockets","content":"This method makes the matching Socket instances disconnect: // make all Socket instances disconnect io.disconnectSockets(); // make all Socket instances in the &quot;room1&quot; room disconnect (and discard the low-level connection) io.in(&quot;room1&quot;).disconnectSockets(true); // make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace disconnect io.of(&quot;/admin&quot;).in(&quot;room1&quot;).disconnectSockets(); // this also works with a single socket ID io.of(&quot;/admin&quot;).in(theSocketId).disconnectSockets(); Copy "},{"title":"fetchSockets​","type":1,"pageTitle":"The Server instance","url":"docs/v1/server-instance/#fetchsockets","content":"This method returns the matching Socket instances: // return all Socket instances of the main namespace const sockets = await io.fetchSockets(); // return all Socket instances in the &quot;room1&quot; room of the main namespace const sockets = await io.in(&quot;room1&quot;).fetchSockets(); // return all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace const sockets = await io.of(&quot;/admin&quot;).in(&quot;room1&quot;).fetchSockets(); // this also works with a single socket ID const sockets = await io.in(theSocketId).fetchSockets(); Copy The sockets variable in the example above is an array of objects exposing a subset of the usual Socket class: for (const socket of sockets) { console.log(socket.id); console.log(socket.handshake); console.log(socket.rooms); console.log(socket.data); socket.emit(/* ... */); socket.join(/* ... */); socket.leave(/* ... */); socket.disconnect(/* ... */); } Copy The data attribute is an arbitrary object that can be used to share information between Socket.IO servers: // server A io.on(&quot;connection&quot;, (socket) =&gt; { socket.data.username = &quot;alice&quot;; }); // server B const sockets = await io.fetchSockets(); console.log(sockets[0].data.username); // &quot;alice&quot; Copy "},{"title":"serverSideEmit​","type":1,"pageTitle":"The Server instance","url":"docs/v1/server-instance/#serversideemit","content":"This method allows to emit events to the other Socket.IO servers of the cluster, in a multi-server setup. Syntax: io.serverSideEmit(&quot;hello&quot;, &quot;world&quot;); Copy And on the receiving side: io.on(&quot;hello&quot;, (arg1) =&gt; { console.log(arg1); // prints &quot;world&quot; }); Copy Acknowledgements are supported too: // server A io.serverSideEmit(&quot;ping&quot;, (err, responses) =&gt; { console.log(responses[0]); // prints &quot;pong&quot; }); // server B io.on(&quot;ping&quot;, (cb) =&gt; { cb(&quot;pong&quot;); }); Copy Notes: the connection, connect and new_namespace strings are reserved and cannot be used in your application. you can send any number of arguments, but binary structures are currently not supported (the array of arguments will be JSON.stringify-ed) Example: io.serverSideEmit(&quot;hello&quot;, &quot;world&quot;, 1, &quot;2&quot;, { 3: &quot;4&quot; }); Copy the acknowledgement callback might be called with an error, if the other Socket.IO servers do not respond after a given delay io.serverSideEmit(&quot;ping&quot;, (err, responses) =&gt; { if (err) { // at least one Socket.IO server has not responded // the 'responses' array contains all the responses already received though } else { // success! the 'responses' array contains one object per other Socket.IO server in the cluster } }); Copy "},{"title":"Events​","type":1,"pageTitle":"The Server instance","url":"docs/v1/server-instance/#events","content":"The Server instance emits one single event (well, technically two, but connect is an alias for connection): connection "},{"title":"connection​","type":1,"pageTitle":"The Server instance","url":"docs/v1/server-instance/#connection","content":"This event is fired upon a new connection. The first argument is a Socket instance. io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); Copy "},{"title":"Complete API​","type":1,"pageTitle":"The Server instance","url":"docs/v1/server-instance/#complete-api","content":"The complete API exposed by the Server instance can be found here. "},{"title":"Testing","type":0,"sectionRef":"#","url":"docs/v1/testing/","content":"","keywords":""},{"title":"Example with mocha​","type":1,"pageTitle":"Testing","url":"docs/v1/testing/#example-with-mocha","content":"Installation: npm i -D mocha chai // with { &quot;type&quot;: &quot;module&quot; } in your package.json import { createServer } from &quot;http&quot;; import { io as Client } from &quot;socket.io-client&quot;; import { Server } from &quot;socket.io&quot;; import { assert } from &quot;chai&quot;; // with { &quot;type&quot;: &quot;commonjs&quot; } in your package.json // const { createServer } = require(&quot;http&quot;); // const { Server } = require(&quot;socket.io&quot;); // const Client = require(&quot;socket.io-client&quot;); // const assert = require(&quot;chai&quot;).assert; describe(&quot;my awesome project&quot;, () =&gt; { let io, serverSocket, clientSocket; before((done) =&gt; { const httpServer = createServer(); io = new Server(httpServer); httpServer.listen(() =&gt; { const port = httpServer.address().port; clientSocket = new Client(`http://localhost:${port}`); io.on(&quot;connection&quot;, (socket) =&gt; { serverSocket = socket; }); clientSocket.on(&quot;connect&quot;, done); }); }); after(() =&gt; { io.close(); clientSocket.close(); }); it(&quot;should work&quot;, (done) =&gt; { clientSocket.on(&quot;hello&quot;, (arg) =&gt; { assert.equal(arg, &quot;world&quot;); done(); }); serverSocket.emit(&quot;hello&quot;, &quot;world&quot;); }); it(&quot;should work (with ack)&quot;, (done) =&gt; { serverSocket.on(&quot;hi&quot;, (cb) =&gt; { cb(&quot;hola&quot;); }); clientSocket.emit(&quot;hi&quot;, (arg) =&gt; { assert.equal(arg, &quot;hola&quot;); done(); }); }); }); Copy "},{"title":"Example with jest​","type":1,"pageTitle":"Testing","url":"docs/v1/testing/#example-with-jest","content":"Installation: npm i -D jest const { createServer } = require(&quot;http&quot;); const { Server } = require(&quot;socket.io&quot;); const Client = require(&quot;socket.io-client&quot;); describe(&quot;my awesome project&quot;, () =&gt; { let io, serverSocket, clientSocket; beforeAll((done) =&gt; { const httpServer = createServer(); io = new Server(httpServer); httpServer.listen(() =&gt; { const port = httpServer.address().port; clientSocket = new Client(`http://localhost:${port}`); io.on(&quot;connection&quot;, (socket) =&gt; { serverSocket = socket; }); clientSocket.on(&quot;connect&quot;, done); }); }); afterAll(() =&gt; { io.close(); clientSocket.close(); }); test(&quot;should work&quot;, (done) =&gt; { clientSocket.on(&quot;hello&quot;, (arg) =&gt; { expect(arg).toBe(&quot;world&quot;); done(); }); serverSocket.emit(&quot;hello&quot;, &quot;world&quot;); }); test(&quot;should work (with ack)&quot;, (done) =&gt; { serverSocket.on(&quot;hi&quot;, (cb) =&gt; { cb(&quot;hola&quot;); }); clientSocket.emit(&quot;hi&quot;, (arg) =&gt; { expect(arg).toBe(&quot;hola&quot;); done(); }); }); }); Copy "},{"title":"Example with tape​","type":1,"pageTitle":"Testing","url":"docs/v1/testing/#example-with-tape","content":"Installation: npm i -D tape const { createServer } = require(&quot;http&quot;); const { Server } = require(&quot;socket.io&quot;); const Client = require(&quot;socket.io-client&quot;); const test = require(&quot;tape&quot;); let io, serverSocket, clientSocket; test(&quot;setup&quot;, (t) =&gt; { const httpServer = createServer(); io = new Server(httpServer); httpServer.listen(() =&gt; { const port = httpServer.address().port; clientSocket = new Client(`http://localhost:${port}`); io.on(&quot;connection&quot;, (socket) =&gt; { serverSocket = socket; }); clientSocket.on(&quot;connect&quot;, t.end); }); }); test(&quot;it works&quot;, (t) =&gt; { t.plan(1); clientSocket.on(&quot;hello&quot;, (arg) =&gt; { t.equal(arg, &quot;world&quot;); }); serverSocket.emit(&quot;hello&quot;, &quot;world&quot;); }); test(&quot;it works (with ack)&quot;, (t) =&gt; { t.plan(1); serverSocket.on(&quot;hi&quot;, (cb) =&gt; { cb(&quot;hola&quot;); }); clientSocket.emit(&quot;hi&quot;, (arg) =&gt; { t.equal(arg, &quot;hola&quot;); }); }); test.onFinish(() =&gt; { io.close(); clientSocket.close(); }); Copy "},{"title":"Using multiple nodes","type":0,"sectionRef":"#","url":"docs/v1/using-multiple-nodes/","content":"","keywords":""},{"title":"Sticky load balancing​","type":1,"pageTitle":"Using multiple nodes","url":"docs/v1/using-multiple-nodes/#sticky-load-balancing","content":"If you plan to distribute the load of connections among different processes or machines, you have to make sure that all requests associated with a particular session ID reach the process that originated them. "},{"title":"Why is sticky-session required​","type":1,"pageTitle":"Using multiple nodes","url":"docs/v1/using-multiple-nodes/#why-is-sticky-session-required","content":"This is because the HTTP long-polling transport sends multiple HTTP requests during the lifetime of the Socket.IO session. In fact, Socket.IO could technically work without sticky sessions, with the following synchronization (in dashed lines):  While obviously possible to implement, we think that this synchronization process between the Socket.IO servers would result in a big performance hit for your application. Remarks: without enabling sticky-session, you will experience HTTP 400 errors due to &quot;Session ID unknown&quot;the WebSocket transport does not have this limitation, since it relies on a single TCP connection for the whole session. Which means that if you disable the HTTP long-polling transport (which is a perfectly valid choice in 2021), you won't need sticky sessions: const socket = io(&quot;https://io.yourhost.com&quot;, { // WARNING: in that case, there is no fallback to long-polling transports: [ &quot;websocket&quot; ] // or [ &quot;websocket&quot;, &quot;polling&quot; ] (the order matters) }); Copy Documentation: transports "},{"title":"Enabling sticky-session​","type":1,"pageTitle":"Using multiple nodes","url":"docs/v1/using-multiple-nodes/#enabling-sticky-session","content":"To achieve sticky-session, there are two main solutions: routing clients based on a cookie (recommended solution)routing clients based on their originating address You will find below some examples with common load-balancing solutions: NginX (IP-based)Apache HTTPD (cookie-based)HAProxy (cookie-based)Traefik (cookie-based)Node.js cluster module For other platforms, please refer to the relevant documentation: Kubernetes: https://kubernetes.github.io/ingress-nginx/examples/affinity/cookie/AWS (Application Load Balancers): https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.htmlGCP: https://cloud.google.com/load-balancing/docs/backend-service#session_affinityHeroku: https://devcenter.heroku.com/articles/session-affinity Important note: if you are in a CORS situation (the front domain is different from the server domain) and session affinity is achieved with a cookie, you need to allow credentials: Server const io = require(&quot;socket.io&quot;)(httpServer, { cors: { origin: &quot;https://front-domain.com&quot;, methods: [&quot;GET&quot;, &quot;POST&quot;], credentials: true } }); Copy Client const io = require(&quot;socket.io-client&quot;); const socket = io(&quot;https://server-domain.com&quot;, { withCredentials: true }); Copy Without it, the cookie will not be sent by the browser and you will experience HTTP 400 &quot;Session ID unknown&quot; responses. More information here. "},{"title":"NginX configuration​","type":1,"pageTitle":"Using multiple nodes","url":"docs/v1/using-multiple-nodes/#nginx-configuration","content":"Within the http { } section of your nginx.conf file, you can declare a upstream section with a list of Socket.IO process you want to balance load between: http { server { listen 3000; server_name io.yourhost.com; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_pass http://nodes; # enable WebSockets proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; } } upstream nodes { # enable sticky session with either &quot;hash&quot; (uses the complete IP address) hash $remote_addr consistent; # or &quot;ip_hash&quot; (uses the first three octets of the client IPv4 address, or the entire IPv6 address) # ip_hash; # or &quot;sticky&quot; (needs commercial subscription) # sticky cookie srv_id expires=1h domain=.example.com path=/; server app01:3000; server app02:3000; server app03:3000; } } Copy Notice the hash instruction that indicates the connections will be sticky. Make sure you also configure worker_processes in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the worker_connections setting within the events { } block. Links: ExampleNginX Documentation "},{"title":"Apache HTTPD configuration​","type":1,"pageTitle":"Using multiple nodes","url":"docs/v1/using-multiple-nodes/#apache-httpd-configuration","content":"Header add Set-Cookie &quot;SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/&quot; env=BALANCER_ROUTE_CHANGED &lt;Proxy &quot;balancer://nodes_polling&quot;&gt; BalancerMember &quot;http://app01:3000&quot; route=app01 BalancerMember &quot;http://app02:3000&quot; route=app02 BalancerMember &quot;http://app03:3000&quot; route=app03 ProxySet stickysession=SERVERID &lt;/Proxy&gt; &lt;Proxy &quot;balancer://nodes_ws&quot;&gt; BalancerMember &quot;ws://app01:3000&quot; route=app01 BalancerMember &quot;ws://app02:3000&quot; route=app02 BalancerMember &quot;ws://app03:3000&quot; route=app03 ProxySet stickysession=SERVERID &lt;/Proxy&gt; RewriteEngine On RewriteCond %{HTTP:Upgrade} =websocket [NC] RewriteRule /(.*) balancer://nodes_ws/$1 [P,L] RewriteCond %{HTTP:Upgrade} !=websocket [NC] RewriteRule /(.*) balancer://nodes_polling/$1 [P,L] ProxyTimeout 3 Copy Links: ExampleDocumentation "},{"title":"HAProxy configuration​","type":1,"pageTitle":"Using multiple nodes","url":"docs/v1/using-multiple-nodes/#haproxy-configuration","content":"# Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/ listen chat bind *:80 default_backend nodes backend nodes option httpchk HEAD /health http-check expect status 200 cookie io prefix indirect nocache # using the `io` cookie set upon handshake server app01 app01:3000 check cookie app01 server app02 app02:3000 check cookie app02 server app03 app03:3000 check cookie app03 Copy Links: ExampleDocumentation "},{"title":"Traefik​","type":1,"pageTitle":"Using multiple nodes","url":"docs/v1/using-multiple-nodes/#traefik","content":"Using container labels: # docker-compose.yml services: traefik: image: traefik:2.4 volumes: - /var/run/docker.sock:/var/run/docker.sock links: - server server: image: my-image:latest labels: - &quot;traefik.http.routers.my-service.rule=PathPrefix(`/`)&quot; - traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id - traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true Copy With the File provider: ## Dynamic configuration http: services: my-service: rule: &quot;PathPrefix(`/`)&quot; loadBalancer: sticky: cookie: name: server_id httpOnly: true Copy Links: ExampleDocumentation "},{"title":"Using Node.js Cluster​","type":1,"pageTitle":"Using multiple nodes","url":"docs/v1/using-multiple-nodes/#using-nodejs-cluster","content":"Just like NginX, Node.js comes with built-in clustering support through the cluster module. There are several solutions, depending on your use case: NPM package\tHow it works@socket.io/sticky\tthe routing is based on the sid query parameter sticky-session\tthe routing is based on connection.remoteAddress socketio-sticky-session\tthe routing based on the x-forwarded-for header) Example with @socket.io/sticky: const cluster = require(&quot;cluster&quot;); const http = require(&quot;http&quot;); const { Server } = require(&quot;socket.io&quot;); const numCPUs = require(&quot;os&quot;).cpus().length; const { setupMaster, setupWorker } = require(&quot;@socket.io/sticky&quot;); const { createAdapter, setupPrimary } = require(&quot;@socket.io/cluster-adapter&quot;); if (cluster.isMaster) { console.log(`Master ${process.pid} is running`); const httpServer = http.createServer(); // setup sticky sessions setupMaster(httpServer, { loadBalancingMethod: &quot;least-connection&quot;, }); // setup connections between the workers setupPrimary(); // needed for packets containing buffers (you can ignore it if you only send plaintext objects) // Node.js &lt; 16.0.0 cluster.setupMaster({ serialization: &quot;advanced&quot;, }); // Node.js &gt; 16.0.0 // cluster.setupPrimary({ // serialization: &quot;advanced&quot;, // }); httpServer.listen(3000); for (let i = 0; i &lt; numCPUs; i++) { cluster.fork(); } cluster.on(&quot;exit&quot;, (worker) =&gt; { console.log(`Worker ${worker.process.pid} died`); cluster.fork(); }); } else { console.log(`Worker ${process.pid} started`); const httpServer = http.createServer(); const io = new Server(httpServer); // use the cluster adapter io.adapter(createAdapter()); // setup connection with the primary process setupWorker(io); io.on(&quot;connection&quot;, (socket) =&gt; { /* ... */ }); } Copy "},{"title":"Passing events between nodes​","type":1,"pageTitle":"Using multiple nodes","url":"docs/v1/using-multiple-nodes/#passing-events-between-nodes","content":"Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to all clients (or to the clients in a certain room) you’ll need some way of passing messages between processes or computers. The interface in charge of routing messages is what we call the Adapter. "},{"title":"Server Initialization","type":0,"sectionRef":"#","url":"docs/v1/server-initialization/","content":"","keywords":""},{"title":"Initialization​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#initialization","content":""},{"title":"Standalone​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#standalone","content":"CommonJSES modulesTypeScript const { Server } = require(&quot;socket.io&quot;); const io = new Server({ /* options */ }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); io.listen(3000); Copy You can also pass the port as the first argument: CommonJSES modulesTypeScript const { Server } = require(&quot;socket.io&quot;); const io = new Server(3000, { /* options */ }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); Copy This implicitly starts a Node.js HTTP server, which can be accessed through io.httpServer. "},{"title":"With an HTTP server​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#with-an-http-server","content":"CommonJSES modulesTypeScript const { createServer } = require(&quot;http&quot;); const { Server } = require(&quot;socket.io&quot;); const httpServer = createServer(); const io = new Server(httpServer, { /* options */ }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); httpServer.listen(3000); Copy "},{"title":"With an HTTPS server​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#with-an-https-server","content":"CommonJSES modulesTypeScript const { readFileSync } = require(&quot;fs&quot;); const { createServer } = require(&quot;https&quot;); const { Server } = require(&quot;socket.io&quot;); const httpServer = createServer({ key: readFileSync(&quot;/path/to/my/key.pem&quot;), cert: readFileSync(&quot;/path/to/my/cert.pem&quot;) }); const io = new Server(httpServer, { /* options */ }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); httpServer.listen(3000); Copy See also: Node.js documentation With client-certificate authentication: Server import { readFileSync } from &quot;fs&quot;; import { createServer } from &quot;https&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer({ key: readFileSync(&quot;/path/to/server-key.pem&quot;), cert: readFileSync(&quot;/path/to/server-cert.pem&quot;), requestCert: true, ca: [ readFileSync(&quot;/path/to/client-cert.pem&quot;) ] }); const io = new Server(httpServer, { /* options */ }); io.engine.on(&quot;connection&quot;, (rawSocket) =&gt; { // if you need the certificate details (it is no longer available once the handshake is completed) rawSocket.peerCertificate = rawSocket.request.client.getPeerCertificate(); }); io.on(&quot;connection&quot;, (socket) =&gt; { console.log(socket.conn.peerCertificate); // ... }); httpServer.listen(3000); Copy Client import { readFileSync } from &quot;fs&quot;; import { io } from &quot;socket.io-client&quot;; const socket = io(&quot;https://example.com&quot;, { key: readFileSync(&quot;/path/to/client-key.pem&quot;), cert: readFileSync(&quot;/path/to/client-cert.pem&quot;), ca: [ readFileSync(&quot;/path/to/server-cert.pem&quot;) ] }); Copy "},{"title":"With an HTTP/2 server​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#with-an-http2-server","content":"CommonJSES modulesTypeScript const { readFileSync } = require(&quot;fs&quot;); const { createSecureServer } = require(&quot;http2&quot;); const { Server } = require(&quot;socket.io&quot;); const httpServer = createSecureServer({ allowHTTP1: true, key: readFileSync(&quot;/path/to/my/key.pem&quot;), cert: readFileSync(&quot;/path/to/my/cert.pem&quot;) }); const io = new Server(httpServer, { /* options */ }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); httpServer.listen(3000); Copy See also: Node.js documentation "},{"title":"With Express​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#with-express","content":"CommonJSES modulesTypeScript const express = require(&quot;express&quot;); const { createServer } = require(&quot;http&quot;); const { Server } = require(&quot;socket.io&quot;); const app = express(); const httpServer = createServer(app); const io = new Server(httpServer, { /* options */ }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); httpServer.listen(3000); Copy caution Using app.listen(3000) will not work here, as it creates a new HTTP server. More information here. "},{"title":"With Koa​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#with-koa","content":"CommonJSES modulesTypeScript const Koa = require(&quot;koa&quot;); const { createServer } = require(&quot;http&quot;); const { Server } = require(&quot;socket.io&quot;); const app = new Koa(); const httpServer = createServer(app.callback()); const io = new Server(httpServer, { /* options */ }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); httpServer.listen(3000); Copy More information here. "},{"title":"With Nest​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#with-nest","content":"See the documentation here. caution NestJS v7 and below relies on Socket.IO v2, while NestJS v8 relies on Socket.IO v4. Please use a compatible client. "},{"title":"With Fastify​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#with-fastify","content":"You need to register the fastify-socket.io plugin: CommonJSES modulesTypeScript const fastify = require(&quot;fastify&quot;); const fastifyIO = require(&quot;fastify-socket.io&quot;); const server = fastify(); server.register(fastifyIO); server.get(&quot;/&quot;, (req, reply) =&gt; { server.io.emit(&quot;hello&quot;); }); server.ready().then(() =&gt; { // we need to wait for the server to be ready, else `server.io` is undefined server.io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); }); server.listen(3000); Copy "},{"title":"With µWebSockets.js​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#with-uwebsocketsjs","content":"import { App } from &quot;uWebSockets.js&quot;; import { Server } from &quot;socket.io&quot;; const app = new App(); const io = new Server(); io.attachApp(app); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); app.listen(3000, (token) =&gt; { if (!token) { console.warn(&quot;port already in use&quot;); } }); Copy Reference: https://github.com/uNetworking/uWebSockets.js "},{"title":"Options​","type":1,"pageTitle":"Server Initialization","url":"docs/v1/server-initialization/#options","content":"The complete list of available options can be found here. "},{"title":"Server API","type":0,"sectionRef":"#","url":"docs/v1/server-api/","content":"","keywords":""},{"title":"Server​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#server","content":"  Related documentation pages: installationinitializationdetails of the server instance "},{"title":"new Server(httpServer[, options])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#new-serverhttpserver-options","content":"httpServer &lt;http.Server&gt; | &lt;https.Server&gt;options &lt;Object&gt; import { createServer } from &quot;http&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer(); const io = new Server(httpServer, { // options }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); httpServer.listen(3000); Copy The complete list of available options can be found here. "},{"title":"new Server(port[, options])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#new-serverport-options","content":"port &lt;number&gt;options &lt;Object&gt; import { Server } from &quot;socket.io&quot;; const io = new Server(3000, { // options }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); Copy The complete list of available options can be found here. "},{"title":"new Server(options)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#new-serveroptions","content":"options &lt;Object&gt; import { Server } from &quot;socket.io&quot;; const io = new Server({ // options }); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); io.listen(3000); Copy The complete list of available options can be found here. "},{"title":"server.sockets​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serversockets","content":"&lt;Namespace&gt; An alias for the main namespace (/). io.sockets.emit(&quot;hi&quot;, &quot;everyone&quot;); // is equivalent to io.of(&quot;/&quot;).emit(&quot;hi&quot;, &quot;everyone&quot;); Copy "},{"title":"server.serveClient([value])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverserveclientvalue","content":"value &lt;boolean&gt;Returns &lt;Server&gt; | &lt;boolean&gt; If value is true the attached server will serve the client files. Defaults to true. This method has no effect after listen is called. If no arguments are supplied this method returns the current value. import { Server } from &quot;socket.io&quot;; const io = new Server(); io.serveClient(false); io.listen(3000); Copy "},{"title":"server.path([value])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverpathvalue","content":"value &lt;string&gt;Returns &lt;Server&gt; | &lt;string&gt; Sets the path value under which engine.io and the static files will be served. Defaults to /socket.io/. If no arguments are supplied this method returns the current value. import { Server } from &quot;socket.io&quot;; const io = new Server(); io.path(&quot;/myownpath/&quot;); Copy warning The path value must match the one on the client side: import { io } from &quot;socket.io-client&quot;; const socket = io({ path: &quot;/myownpath/&quot; }); Copy "},{"title":"server.adapter([value])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serveradaptervalue","content":"value &lt;Adapter&gt;Returns &lt;Server&gt; | &lt;Adapter&gt; Sets the adapter value. Defaults to an instance of the Adapter that ships with socket.io which is memory based. See socket.io-adapter. If no arguments are supplied this method returns the current value. import { Server } from &quot;socket.io&quot;; import { createAdapter } from &quot;@socket.io/redis-adapter&quot;; import { createClient } from &quot;redis&quot;; const io = new Server(); const pubClient = createClient({ host: &quot;localhost&quot;, port: 6379 }); const subClient = pubClient.duplicate(); io.adapter(createAdapter(pubClient, subClient)); // redis@3 io.listen(3000); // redis@4 Promise.all([pubClient.connect(), subClient.connect()]).then(() =&gt; { io.listen(3000); }); Copy "},{"title":"server.attach(httpServer[, options])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverattachhttpserver-options","content":"httpServer &lt;http.Server&gt; | &lt;https.Server&gt;options &lt;Object&gt; Attaches the Server to an httpServer with the supplied options. import { createServer } from &quot;http&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer(); const io = new Server(); io.attach(httpServer); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); httpServer.listen(3000); Copy "},{"title":"server.attach(port[, options])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverattachport-options","content":"port &lt;number&gt;options &lt;Object&gt; Attaches the Server on the given port with the supplied options. import { Server } from &quot;socket.io&quot;; const io = new Server(); io.attach(3000); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); Copy "},{"title":"server.attachApp(app[, options])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverattachappapp-options","content":"app &lt;uws.App&gt;options &lt;Object&gt; Attaches the Socket.IO server to an µWebSockets.js app: import { App } from &quot;uWebSockets.js&quot;; import { Server } from &quot;socket.io&quot;; const app = new App(); const io = new Server(); io.attachApp(app); io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); app.listen(3000, (token) =&gt; { if (!token) { console.warn(&quot;port already in use&quot;); } }); Copy "},{"title":"server.listen(httpServer[, options])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverlistenhttpserver-options","content":"Synonym of server.attach(httpServer[, options]). "},{"title":"server.listen(port[, options])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverlistenport-options","content":"Synonym of server.attach(port[, options]). "},{"title":"server.on(eventName, listener)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serveroneventname-listener","content":"Inherited from the EventEmitter class. eventName &lt;string&gt; | &lt;symbol&gt;listener &lt;Function&gt;Returns &lt;Server&gt; Adds the listener function to the end of the listeners array for the event named eventName. Available events: connectionnew_namespaceany custom event from the serverSideEmit method io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); Copy "},{"title":"server.bind(engine)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverbindengine","content":"engine &lt;engine.Server&gt;Returns &lt;Server&gt; Advanced use only. Binds the server to a specific engine.io Server (or compatible API) instance. import { Server } from &quot;socket.io&quot;; import { Server as Engine } from &quot;engine.io&quot;; const engine = new Engine(); const io = new Server(); io.bind(engine); engine.listen(3000); Copy "},{"title":"server.onconnection(socket)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serveronconnectionsocket","content":"socket &lt;engine.Socket&gt;Returns &lt;Server&gt; Advanced use only. Creates a new socket.io client from the incoming engine.io (or compatible API) Socket. import { Server } from &quot;socket.io&quot;; import { Server as Engine } from &quot;engine.io&quot;; const engine = new Engine(); const io = new Server(); engine.on(&quot;connection&quot;, (socket) =&gt; { io.onconnection(socket); }); engine.listen(3000); Copy "},{"title":"server.of(nsp)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverofnsp","content":"nsp &lt;string&gt; | &lt;RegExp&gt; | &lt;Function&gt;Returns &lt;Namespace&gt; Initializes and retrieves the given Namespace by its pathname identifier nsp. If the namespace was already initialized it returns it immediately. const adminNamespace = io.of(&quot;/admin&quot;); Copy A regex or a function can also be provided, in order to create namespace in a dynamic way: const dynamicNsp = io.of(/^\\/dynamic-\\d+$/).on(&quot;connection&quot;, (socket) =&gt; { const newNamespace = socket.nsp; // newNamespace.name === &quot;/dynamic-101&quot; // broadcast to all clients in the given sub-namespace newNamespace.emit(&quot;hello&quot;); }); // client-side const socket = io(&quot;/dynamic-101&quot;); // broadcast to all clients in each sub-namespace dynamicNsp.emit(&quot;hello&quot;); // use a middleware for each sub-namespace dynamicNsp.use((socket, next) =&gt; { /* ... */ }); Copy With a function: io.of((name, query, next) =&gt; { // the checkToken method must return a boolean, indicating whether the client is able to connect or not. next(null, checkToken(query.token)); }).on(&quot;connection&quot;, (socket) =&gt; { /* ... */ }); Copy "},{"title":"server.close([callback])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverclosecallback","content":"callback &lt;Function&gt; Closes the Socket.IO server and disconnect all clients. The callback argument is optional and will be called when all connections are closed. info This also closes the underlying HTTP server. import { createServer } from &quot;http&quot;; import { Server } from &quot;socket.io&quot;; const PORT = 3030; const io = new Server(PORT); io.close(); const httpServer = createServer(); httpServer.listen(PORT); // PORT is free to use io.attach(httpServer); Copy note Only closing the underlying HTTP server is not sufficient, as it will only prevent the server from accepting new connections but clients connected with WebSocket will not be disconnected right away. Reference: https://nodejs.org/api/http.html#serverclosecallback "},{"title":"server.engine​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverengine","content":"A reference to the underlying Engine.IO server. See here. "},{"title":"server.socketsJoin(rooms)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serversocketsjoinrooms","content":"Added in v4.0.0 Alias for io.of(&quot;/&quot;).socketsJoin(rooms). // make all Socket instances join the &quot;room1&quot; room io.socketsJoin(&quot;room1&quot;); // make all Socket instances in the &quot;room1&quot; room join the &quot;room2&quot; and &quot;room3&quot; rooms io.in(&quot;room1&quot;).socketsJoin([&quot;room2&quot;, &quot;room3&quot;]); // this also works with a single socket ID io.in(theSocketId).socketsJoin(&quot;room1&quot;); Copy See here. "},{"title":"server.socketsLeave(rooms)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serversocketsleaverooms","content":"Added in v4.0.0 Alias for io.of(&quot;/&quot;).socketsLeave(rooms). // make all Socket instances leave the &quot;room1&quot; room io.socketsLeave(&quot;room1&quot;); // make all Socket instances in the &quot;room1&quot; room leave the &quot;room2&quot; and &quot;room3&quot; rooms io.in(&quot;room1&quot;).socketsLeave([&quot;room2&quot;, &quot;room3&quot;]); // this also works with a single socket ID io.in(theSocketId).socketsLeave(&quot;room1&quot;); Copy See here. "},{"title":"server.disconnectSockets([close])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverdisconnectsocketsclose","content":"Added in v4.0.0 Alias for io.of(&quot;/&quot;).disconnectSockets(close). // make all Socket instances disconnect io.disconnectSockets(); // make all Socket instances in the &quot;room1&quot; room disconnect (and close the low-level connection) io.in(&quot;room1&quot;).disconnectSockets(true); Copy See here. "},{"title":"server.fetchSockets()​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverfetchsockets","content":"Added in v4.0.0 Alias for io.of(&quot;/&quot;).fetchSocket(). // return all Socket instances of the main namespace const sockets = await io.fetchSockets(); // return all Socket instances in the &quot;room1&quot; room of the main namespace const sockets = await io.in(&quot;room1&quot;).fetchSockets(); Copy Sample usage: io.on(&quot;connection&quot;, (socket) =&gt; { const userId = computeUserId(socket); socket.join(userId); socket.on(&quot;disconnect&quot;, async () =&gt; { const sockets = await io.in(userId).fetchSockets(); if (socket.length === 0) { // no more active connections for the given user } }); }); Copy See here. "},{"title":"server.serverSideEmit(eventName[, ...args][, ack])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#serverserversideemiteventname-args","content":"Added in v4.1.0 Alias for: io.of(&quot;/&quot;).serverSideEmit(/* ... */); "},{"title":"Event: connection​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#event-connection","content":"socket (Socket) socket connection with client Fired upon a connection from client. io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); Copy "},{"title":"Event: connect​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#event-connect","content":"Synonym of Event: &quot;connection&quot;. "},{"title":"Event: new_namespace​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#event-new_namespace","content":"namespace Namespace Fired when a new namespace is created: io.on(&quot;new_namespace&quot;, (namespace) =&gt; { // ... }); Copy This can be useful for example: to attach a shared middleware to each namespace io.on(&quot;new_namespace&quot;, (namespace) =&gt; { namespace.use(myMiddleware); }); Copy to track the dynamically created namespaces io.of(/\\/nsp-\\w+/); io.on(&quot;new_namespace&quot;, (namespace) =&gt; { console.log(namespace.name); }); Copy "},{"title":"Namespace​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespace","content":"  Represents a pool of sockets connected under a given scope identified by a pathname (eg: /chat). More information can be found here. "},{"title":"namespace.name​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespacename","content":"&lt;string&gt; The namespace identifier property. "},{"title":"namespace.sockets​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespacesockets","content":"Map&lt;SocketId, Socket&gt; A map of Socket instances that are connected to this namespace. // number of sockets in this namespace (on this node) const socketCount = io.of(&quot;/admin&quot;).sockets.size; Copy "},{"title":"namespace.adapter​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespaceadapter","content":"&lt;Adapter&gt; The &quot;Adapter&quot; used for the namespace. Note: the adapter of the main namespace can be accessed with io.of(&quot;/&quot;).adapter. More information about it here. const adapter = io.of(&quot;/my-namespace&quot;).adapter; Copy "},{"title":"namespace.to(room)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespacetoroom","content":"History Version\tChangesv4.0.0\tAllow to pass an array of rooms. v1.0.0\tInitial implementation. room &lt;string&gt; | &lt;string[]&gt;Returns BroadcastOperator for chaining Sets a modifier for a subsequent event emission that the event will only be broadcast to clients that have joined the given room. To emit to multiple rooms, you can call to several times. const io = require(&quot;socket.io&quot;)(); const adminNamespace = io.of(&quot;/admin&quot;); adminNamespace.to(&quot;level1&quot;).emit(&quot;an event&quot;, { some: &quot;data&quot; }); // multiple rooms io.to(&quot;room1&quot;).to(&quot;room2&quot;).emit(/* ... */); // or with an array io.to([&quot;room1&quot;, &quot;room2&quot;]).emit(/* ... */); Copy "},{"title":"namespace.in(room)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespaceinroom","content":"Added in v1.0.0 Synonym of namespace.to(room). "},{"title":"namespace.except(rooms)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespaceexceptrooms","content":"Added in v4.0.0 rooms &lt;string&gt; | &lt;string[]&gt;Returns BroadcastOperator Sets a modifier for a subsequent event emission that the event will only be broadcast to clients that have not joined the given rooms. // to all clients except the ones in &quot;room1&quot; io.except(&quot;room1&quot;).emit(/* ... */); // to all clients in &quot;room2&quot; except the ones in &quot;room3&quot; io.to(&quot;room2&quot;).except(&quot;room3&quot;).emit(/* ... */); Copy "},{"title":"namespace.emit(eventName[, ...args])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespaceemiteventname-args","content":"eventName &lt;string&gt; | &lt;symbol&gt;args any[]Returns true Emits an event to all connected clients in the given namespace. io.emit(&quot;an event sent to all connected clients&quot;); // main namespace const chat = io.of(&quot;/chat&quot;); chat.emit(&quot;an event sent to all connected clients in chat namespace&quot;); Copy info Starting with version 4.5.0, it is now possible to use acknowledgements when broadcasting: io.of(&quot;/chat&quot;).timeout(10000).emit(&quot;some-event&quot;, (err, responses) =&gt; { if (err) { // some clients did not acknowledge the event in the given delay } else { console.log(responses); // one response per client } }); Copy "},{"title":"namespace.timeout(value)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespacetimeoutvalue","content":"Added in v4.5.0 value &lt;number&gt;Returns BroadcastOperator Sets a modifier for a subsequent event emission that the callback will be called with an error when the given number of milliseconds have elapsed without an acknowledgement from the client: io.of(&quot;/chat&quot;).timeout(10000).emit(&quot;some-event&quot;, (err, responses) =&gt; { if (err) { // some clients did not acknowledge the event in the given delay } else { console.log(responses); // one response per client } }); Copy "},{"title":"namespace.allSockets()​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespaceallsockets","content":"Returns Promise&lt;Set&lt;SocketId&gt;&gt; Gets a list of socket IDs connected to this namespace (across all nodes if applicable). // all sockets in the main namespace const ids = await io.allSockets(); // all sockets in the main namespace and in the &quot;user:1234&quot; room const ids = await io.in(&quot;user:1234&quot;).allSockets(); // all sockets in the &quot;chat&quot; namespace const ids = await io.of(&quot;/chat&quot;).allSockets(); // all sockets in the &quot;chat&quot; namespace and in the &quot;general&quot; room const ids = await io.of(&quot;/chat&quot;).in(&quot;general&quot;).allSockets(); Copy "},{"title":"namespace.use(fn)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespaceusefn","content":"fn &lt;Function&gt; Registers a middleware, which is a function that gets executed for every incoming Socket, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware. Errors passed to middleware callbacks are sent as special connect_error packets to clients. // server-side io.use((socket, next) =&gt; { const err = new Error(&quot;not authorized&quot;); err.data = { content: &quot;Please retry later&quot; }; // additional details next(err); }); // client-side socket.on(&quot;connect_error&quot;, err =&gt; { console.log(err instanceof Error); // true console.log(err.message); // not authorized console.log(err.data); // { content: &quot;Please retry later&quot; } }); Copy More information can be found here. "},{"title":"namespace.socketsJoin(rooms)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespacesocketsjoinrooms","content":"Added in v4.0.0 rooms &lt;string&gt; | &lt;string[]&gt;Returns void Makes the matching Socket instances join the specified rooms: // make all Socket instances join the &quot;room1&quot; room io.socketsJoin(&quot;room1&quot;); // make all Socket instances in the &quot;room1&quot; room join the &quot;room2&quot; and &quot;room3&quot; rooms io.in(&quot;room1&quot;).socketsJoin([&quot;room2&quot;, &quot;room3&quot;]); // make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace join the &quot;room2&quot; room io.of(&quot;/admin&quot;).in(&quot;room1&quot;).socketsJoin(&quot;room2&quot;); // this also works with a single socket ID io.in(theSocketId).socketsJoin(&quot;room1&quot;); Copy More information can be found here. "},{"title":"namespace.socketsLeave(rooms)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespacesocketsleaverooms","content":"Added in v4.0.0 rooms &lt;string&gt; | &lt;string[]&gt;Returns void Makes the matching Socket instances leave the specified rooms: // make all Socket instances leave the &quot;room1&quot; room io.socketsLeave(&quot;room1&quot;); // make all Socket instances in the &quot;room1&quot; room leave the &quot;room2&quot; and &quot;room3&quot; rooms io.in(&quot;room1&quot;).socketsLeave([&quot;room2&quot;, &quot;room3&quot;]); // make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace leave the &quot;room2&quot; room io.of(&quot;/admin&quot;).in(&quot;room1&quot;).socketsLeave(&quot;room2&quot;); // this also works with a single socket ID io.in(theSocketId).socketsLeave(&quot;room1&quot;); Copy "},{"title":"namespace.disconnectSockets([close])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespacedisconnectsocketsclose","content":"Added in v4.0.0 close &lt;boolean&gt; whether to close the underlying connectionReturns void Makes the matching Socket instances disconnect. // make all Socket instances disconnect io.disconnectSockets(); // make all Socket instances in the &quot;room1&quot; room disconnect (and discard the low-level connection) io.in(&quot;room1&quot;).disconnectSockets(true); // make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace disconnect io.of(&quot;/admin&quot;).in(&quot;room1&quot;).disconnectSockets(); // this also works with a single socket ID io.of(&quot;/admin&quot;).in(theSocketId).disconnectSockets(); Copy "},{"title":"namespace.fetchSockets()​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespacefetchsockets","content":"Added in v4.0.0 Returns Socket[] | RemoteSocket[] Returns the matching Socket instances: // return all Socket instances in the main namespace const sockets = await io.fetchSockets(); // return all Socket instances in the &quot;room1&quot; room of the main namespace const sockets = await io.in(&quot;room1&quot;).fetchSockets(); // return all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace const sockets = await io.of(&quot;/admin&quot;).in(&quot;room1&quot;).fetchSockets(); // this also works with a single socket ID const sockets = await io.in(theSocketId).fetchSockets(); Copy The sockets variable in the example above is an array of objects exposing a subset of the usual Socket class: for (const socket of sockets) { console.log(socket.id); console.log(socket.handshake); console.log(socket.rooms); console.log(socket.data); socket.emit(/* ... */); socket.join(/* ... */); socket.leave(/* ... */); socket.disconnect(/* ... */); } Copy The data attribute is an arbitrary object that can be used to share information between Socket.IO servers: // server A io.on(&quot;connection&quot;, (socket) =&gt; { socket.data.username = &quot;alice&quot;; }); // server B const sockets = await io.fetchSockets(); console.log(sockets[0].data.username); // &quot;alice&quot; Copy Important note: this method (and socketsJoin, socketsLeave and disconnectSockets too) is compatible with the Redis adapter (starting with socket.io-redis@6.1.0), which means that they will work across Socket.IO servers. "},{"title":"namespace.serverSideEmit(eventName[, ...args][, ack])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#namespaceserversideemiteventname-args","content":"Added in v4.1.0 eventName &lt;string&gt;args &lt;any[]&gt;ack &lt;Function&gt;Returns true Sends a message to the other Socket.IO servers of the cluster. Syntax: io.serverSideEmit(&quot;hello&quot;, &quot;world&quot;); Copy And on the receiving side: io.on(&quot;hello&quot;, (arg1) =&gt; { console.log(arg1); // prints &quot;world&quot; }); Copy Acknowledgements are supported too: // server A io.serverSideEmit(&quot;ping&quot;, (err, responses) =&gt; { console.log(responses[0]); // prints &quot;pong&quot; }); // server B io.on(&quot;ping&quot;, (cb) =&gt; { cb(&quot;pong&quot;); }); Copy Notes: the connection, connect and new_namespace strings are reserved and cannot be used in your application. you can send any number of arguments, but binary structures are currently not supported (the array of arguments will be JSON.stringify-ed) Example: io.serverSideEmit(&quot;hello&quot;, &quot;world&quot;, 1, &quot;2&quot;, { 3: &quot;4&quot; }); Copy the acknowledgement callback might be called with an error, if the other Socket.IO servers do not respond after a given delay io.serverSideEmit(&quot;ping&quot;, (err, responses) =&gt; { if (err) { // at least one Socket.IO server has not responded // the 'responses' array contains all the responses already received though } else { // success! the 'responses' array contains one object per other Socket.IO server in the cluster } }); Copy "},{"title":"Event: 'connection'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#event-connection-1","content":"socket &lt;Socket&gt; Fired upon a connection from client. // main namespace io.on(&quot;connection&quot;, (socket) =&gt; { // ... }); // custom namespace io.of(&quot;/admin&quot;).on(&quot;connection&quot;, (socket) =&gt; { // ... }); Copy "},{"title":"Event: 'connect'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#event-connect-1","content":"Synonym of Event: &quot;connection&quot;. "},{"title":"Flag: 'volatile'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#flag-volatile","content":"Sets a modifier for a subsequent event emission that the event data may be lost if the clients are not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle). io.volatile.emit(&quot;an event&quot;, { some: &quot;data&quot; }); // the clients may or may not receive it Copy "},{"title":"Flag: 'local'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#flag-local","content":"Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node (when scaling to multiple nodes). io.local.emit(&quot;an event&quot;, { some: &quot;data&quot; }); Copy "},{"title":"Socket​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socket","content":"  A Socket is the fundamental class for interacting with browser clients. A Socket belongs to a certain Namespace (by default /) and uses an underlying Client to communicate. It should be noted the Socket doesn't relate directly to the actual underlying TCP/IP socket and it is only the name of the class. Within each Namespace, you can also define arbitrary channels (called room) that the Socket can join and leave. That provides a convenient way to broadcast to a group of Sockets (see Socket#to below). The Socket class inherits from EventEmitter. The Socket class overrides the emit method, and does not modify any other EventEmitter method. All methods documented here which also appear as EventEmitter methods (apart from emit) are implemented by EventEmitter, and documentation for EventEmitter applies. More information can be found here. "},{"title":"socket.id​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketid","content":"&lt;string&gt; A unique identifier for the session, that comes from the underlying Client. "},{"title":"socket.rooms​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketrooms","content":"Set&lt;string&gt; A Set of strings identifying the rooms this client is in. io.on(&quot;connection&quot;, (socket) =&gt; { console.log(socket.rooms); // Set { &lt;socket.id&gt; } socket.join(&quot;room1&quot;); console.log(socket.rooms); // Set { &lt;socket.id&gt;, &quot;room1&quot; } }); Copy "},{"title":"socket.client​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketclient","content":"&lt;Client&gt; A reference to the underlying Client object. "},{"title":"socket.conn​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketconn","content":"&lt;engine.Socket&gt; A reference to the underlying Client transport connection (engine.io Socket object). This allows access to the IO transport layer, which still (mostly) abstracts the actual TCP/IP socket. io.on(&quot;connection&quot;, (socket) =&gt; { console.log(&quot;initial transport&quot;, socket.conn.transport.name); // prints &quot;polling&quot; socket.conn.once(&quot;upgrade&quot;, () =&gt; { // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket) console.log(&quot;upgraded transport&quot;, socket.conn.transport.name); // prints &quot;websocket&quot; }); socket.conn.on(&quot;packet&quot;, ({ type, data }) =&gt; { // called for each packet received }); socket.conn.on(&quot;packetCreate&quot;, ({ type, data }) =&gt; { // called for each packet sent }); socket.conn.on(&quot;drain&quot;, () =&gt; { // called when the write buffer is drained }); socket.conn.on(&quot;close&quot;, (reason) =&gt; { // called when the underlying connection is closed }); }); Copy "},{"title":"socket.request​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketrequest","content":"&lt;http.IncomingMessage&gt; A getter proxy that returns the reference to the request that originated the underlying engine.io Client. Useful for accessing request headers such as Cookie or User-Agent. import { parse } from &quot;cookie&quot;; io.on(&quot;connection&quot;, (socket) =&gt; { const cookies = parse(socket.request.headers.cookie || &quot;&quot;); }); Copy "},{"title":"socket.handshake​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#sockethandshake","content":"&lt;Object&gt; The handshake details: { headers: /* the headers sent as part of the handshake */, time: /* the date of creation (as string) */, address: /* the ip of the client */, xdomain: /* whether the connection is cross-domain */, secure: /* whether the connection is secure */, issued: /* the date of creation (as unix timestamp) */, url: /* the request URL string */, query: /* the query parameters of the first request */, auth: /* the authentication payload */ } Copy Usage: io.use((socket, next) =&gt; { let handshake = socket.handshake; // ... }); io.on(&quot;connection&quot;, (socket) =&gt; { let handshake = socket.handshake; // ... }); Copy "},{"title":"socket.data​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketdata","content":"Added in v4.0.0 An arbitrary object that can be used in conjunction with the fetchSockets() utility method: io.on(&quot;connection&quot;, (socket) =&gt; { socket.data.username = &quot;alice&quot;; }); const sockets = await io.fetchSockets(); console.log(sockets[0].data.username); // &quot;alice&quot; Copy tip This also works within a Socket.IO cluster, with a compatible adapter like the Postgres adapter. "},{"title":"socket.use(fn)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketusefn","content":"History Version\tChangesv3.0.5\tRestoration of the first implementation. v3.0.0\tRemoval in favor of socket.onAny(). v1.7.2\tThe error event is sent directly to the client. v1.6.0\tFirst implementation. fn &lt;Function&gt; Registers a middleware, which is a function that gets executed for every incoming Packet and receives as parameter the packet and a function to optionally defer execution to the next registered middleware. Errors passed to the middleware callback are then emitted as error events on the server-side: io.on(&quot;connection&quot;, (socket) =&gt; { socket.use(([event, ...args], next) =&gt; { if (isUnauthorized(event)) { return next(new Error(&quot;unauthorized event&quot;)); } // do not forget to call next next(); }); socket.on(&quot;error&quot;, (err) =&gt; { if (err &amp;&amp; err.message === &quot;unauthorized event&quot;) { socket.disconnect(); } }); }); Copy "},{"title":"socket.send([...args][, ack])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketsendargs","content":"args &lt;any[]&gt;ack &lt;Function&gt;Returns Socket Sends a message event. See socket.emit(eventName[, ...args][, ack]). "},{"title":"socket.emit(eventName[, ...args][, ack])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketemiteventname-args","content":"(overrides EventEmitter.emit) eventName &lt;string&gt; | &lt;symbol&gt;args &lt;any[]&gt;ack &lt;Function&gt;Returns true Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable datastructures are supported, including Buffer. socket.emit(&quot;hello&quot;, &quot;world&quot;); socket.emit(&quot;with-binary&quot;, 1, &quot;2&quot;, { 3: &quot;4&quot;, 5: Buffer.from([6]) }); Copy The ack argument is optional and will be called with the client's answer. Server io.on(&quot;connection&quot;, (socket) =&gt; { socket.emit(&quot;hello&quot;, &quot;world&quot;, (response) =&gt; { console.log(response); // &quot;got it&quot; }); }); Copy Client socket.on(&quot;hello&quot;, (arg, callback) =&gt; { console.log(arg); // &quot;world&quot; callback(&quot;got it&quot;); }); Copy "},{"title":"socket.on(eventName, callback)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketoneventname-callback","content":"Inherited from the EventEmitter class. eventName &lt;string&gt; | &lt;symbol&gt;callback &lt;Function&gt;Returns &lt;Socket&gt; Register a new handler for the given event. socket.on(&quot;news&quot;, (data) =&gt; { console.log(data); }); // with several arguments socket.on(&quot;news&quot;, (arg1, arg2, arg3) =&gt; { // ... }); // or with acknowledgement socket.on(&quot;news&quot;, (data, callback) =&gt; { callback(0); }); Copy "},{"title":"socket.once(eventName, listener)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketonceeventname-listener","content":""},{"title":"socket.removeListener(eventName, listener)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketremovelistenereventname-listener","content":""},{"title":"socket.removeAllListeners([eventName])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketremovealllistenerseventname","content":""},{"title":"socket.eventNames()​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketeventnames","content":"Inherited from EventEmitter (along with other methods not mentioned here). See the Node.js documentation for the events module. "},{"title":"socket.onAny(callback)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketonanycallback","content":"callback &lt;Function&gt; Register a new catch-all listener. socket.onAny((event, ...args) =&gt; { console.log(`got ${event}`); }); Copy "},{"title":"socket.prependAny(callback)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketprependanycallback","content":"callback &lt;Function&gt; Register a new catch-all listener. The listener is added to the beginning of the listeners array. socket.prependAny((event, ...args) =&gt; { console.log(`got ${event}`); }); Copy "},{"title":"socket.offAny([listener])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketoffanylistener","content":"listener &lt;Function&gt; Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed. const myListener = () =&gt; { /* ... */ }; socket.onAny(myListener); // then, later socket.offAny(myListener); socket.offAny(); Copy "},{"title":"socket.listenersAny()​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketlistenersany","content":"Returns &lt;Function[]&gt; Returns the list of registered catch-all listeners. const listeners = socket.listenersAny(); Copy "},{"title":"socket.onAnyOutgoing(callback)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketonanyoutgoingcallback","content":"Added in v4.5.0 callback &lt;Function&gt; Register a new catch-all listener for outgoing packets. socket.onAnyOutgoing((event, ...args) =&gt; { console.log(`got ${event}`); }); Copy "},{"title":"socket.prependAnyOutgoing(callback)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketprependanyoutgoingcallback","content":"Added in v4.5.0 callback &lt;Function&gt; Register a new catch-all listener for outgoing packets. The listener is added to the beginning of the listeners array. socket.prependAnyOutgoing((event, ...args) =&gt; { console.log(`got ${event}`); }); Copy "},{"title":"socket.offAnyOutgoing([listener])​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketoffanyoutgoinglistener","content":"Added in v4.5.0 listener &lt;Function&gt; Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed. const myListener = () =&gt; { /* ... */ }; socket.onAnyOutgoing(myListener); // remove a single listener socket.offAnyOutgoing(myListener); // remove all listeners socket.offAnyOutgoing(); Copy "},{"title":"socket.listenersAnyOutgoing()​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketlistenersanyoutgoing","content":"Added in v4.5.0 Returns &lt;Function[]&gt; Returns the list of registered catch-all listeners for outgoing packets. const listeners = socket.listenersAnyOutgoing(); Copy "},{"title":"socket.join(room)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketjoinroom","content":"room &lt;string&gt; | &lt;string[]&gt;Returns void | Promise Adds the socket to the given room or to the list of rooms. io.on(&quot;connection&quot;, (socket) =&gt; { socket.join(&quot;room 237&quot;); console.log(socket.rooms); // Set { &lt;socket.id&gt;, &quot;room 237&quot; } socket.join([&quot;room 237&quot;, &quot;room 238&quot;]); io.to(&quot;room 237&quot;).emit(&quot;a new user has joined the room&quot;); // broadcast to everyone in the room }); Copy The mechanics of joining rooms are handled by the Adapter that has been configured (see Server#adapter above), defaulting to socket.io-adapter. For your convenience, each socket automatically joins a room identified by its id (see Socket#id). This makes it easy to broadcast messages to other sockets: io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;say to someone&quot;, (id, msg) =&gt; { // send a private message to the socket with the given id socket.to(id).emit(&quot;my message&quot;, msg); }); }); Copy "},{"title":"socket.leave(room)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketleaveroom","content":"room &lt;string&gt;Returns void | Promise Removes the socket from the given room. io.on(&quot;connection&quot;, (socket) =&gt; { socket.leave(&quot;room 237&quot;); io.to(&quot;room 237&quot;).emit(`user ${socket.id} has left the room`); }); Copy info Rooms are left automatically upon disconnection. "},{"title":"socket.to(room)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#sockettoroom","content":"History Version\tChangesv4.0.0\tAllow to pass an array of rooms. v1.0.0\tInitial implementation. room &lt;string&gt; | &lt;string[]&gt;Returns Socket for chaining Sets a modifier for a subsequent event emission that the event will only be broadcast to clients that have joined the given room (the socket itself being excluded). To emit to multiple rooms, you can call to several times. io.on(&quot;connection&quot;, (socket) =&gt; { // to one room socket.to(&quot;others&quot;).emit(&quot;an event&quot;, { some: &quot;data&quot; }); // to multiple rooms socket.to(&quot;room1&quot;).to(&quot;room2&quot;).emit(&quot;hello&quot;); // or with an array socket.to([&quot;room1&quot;, &quot;room2&quot;]).emit(&quot;hello&quot;); // a private message to another socket socket.to(/* another socket id */).emit(&quot;hey&quot;); // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room // named `socket.id` but the sender. Please use the classic `socket.emit()` instead. }); Copy Note: acknowledgements are not supported when broadcasting. "},{"title":"socket.in(room)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketinroom","content":"Added in v1.0.0 Synonym of socket.to(room). "},{"title":"socket.except(rooms)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketexceptrooms","content":"Added in v4.0.0 rooms &lt;string&gt; | &lt;string[]&gt;Returns BroadcastOperator Sets a modifier for a subsequent event emission that the event will only be broadcast to clients that have not joined the given rooms (the socket itself being excluded). // to all clients except the ones in &quot;room1&quot; and the sender socket.broadcast.except(&quot;room1&quot;).emit(/* ... */); // same as above socket.except(&quot;room1&quot;).emit(/* ... */); // to all clients in &quot;room4&quot; except the ones in &quot;room5&quot; and the sender socket.to(&quot;room4&quot;).except(&quot;room5&quot;).emit(/* ... */); Copy "},{"title":"socket.compress(value)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketcompressvalue","content":"value &lt;boolean&gt; whether to following packet will be compressedReturns Socket for chaining Sets a modifier for a subsequent event emission that the event data will only be compressed if the value is true. Defaults to true when you don't call the method. io.on(&quot;connection&quot;, (socket) =&gt; { socket.compress(false).emit(&quot;uncompressed&quot;, &quot;that's rough&quot;); }); Copy "},{"title":"socket.timeout(value)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#sockettimeoutvalue","content":"Added in v4.4.0 value &lt;number&gt;Returns &lt;Socket&gt; Sets a modifier for a subsequent event emission that the callback will be called with an error when the given number of milliseconds have elapsed without an acknowledgement from the client: socket.timeout(5000).emit(&quot;my-event&quot;, (err) =&gt; { if (err) { // the client did not acknowledge the event in the given delay } }); Copy "},{"title":"socket.disconnect(close)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#socketdisconnectclose","content":"close &lt;boolean&gt; whether to close the underlying connectionReturns Socket Disconnects this socket. If value of close is true, closes the underlying connection. Otherwise, it just disconnects the namespace. io.on(&quot;connection&quot;, (socket) =&gt; { setTimeout(() =&gt; socket.disconnect(true), 5000); }); Copy "},{"title":"Flag: 'broadcast'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#flag-broadcast","content":"Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the sender. io.on(&quot;connection&quot;, (socket) =&gt; { socket.broadcast.emit(&quot;an event&quot;, { some: &quot;data&quot; }); // everyone gets it but the sender }); Copy "},{"title":"Flag: 'volatile'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#flag-volatile-1","content":"Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle). io.on(&quot;connection&quot;, (socket) =&gt; { socket.volatile.emit(&quot;an event&quot;, { some: &quot;data&quot; }); // the client may or may not receive it }); Copy "},{"title":"Event: 'disconnect'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#event-disconnect","content":"reason &lt;string&gt; the reason of the disconnection (either client or server-side) Fired upon disconnection. io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;disconnect&quot;, (reason) =&gt; { // ... }); }); Copy Possible reasons: Reason\tDescriptionserver namespace disconnect\tThe socket was forcefully disconnected with socket.disconnect() client namespace disconnect\tThe client has manually disconnected the socket using socket.disconnect() server shutting down\tThe server is, well, shutting down ping timeout\tThe client did not send a PONG packet in the pingTimeout delay transport close\tThe connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G) transport error\tThe connection has encountered an error "},{"title":"Event: 'disconnecting'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#event-disconnecting","content":"reason &lt;string&gt; the reason of the disconnection (either client or server-side) Fired when the client is going to be disconnected (but hasn't left its rooms yet). io.on(&quot;connection&quot;, (socket) =&gt; { socket.on(&quot;disconnecting&quot;, (reason) =&gt; { console.log(socket.rooms); // Set { ... } }); }); Copy Note: those events, along with connect, connect_error, newListener and removeListener, are special events that shouldn't be used in your application: // BAD, will throw an error socket.emit(&quot;disconnect&quot;); Copy "},{"title":"Client​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#client","content":"  The Client class represents an incoming transport (engine.io) connection. A Client can be associated with many multiplexed Sockets that belong to different Namespaces. "},{"title":"client.conn​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#clientconn","content":"&lt;engine.Socket&gt; A reference to the underlying engine.io Socket connection. "},{"title":"client.request​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#clientrequest","content":"&lt;http.IncomingMessage&gt; A getter proxy that returns the reference to the request that originated the engine.io connection. Useful for accessing request headers such as Cookie or User-Agent. "},{"title":"Engine​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#engine","content":"The Engine.IO server, which manages the WebSocket / HTTP long-polling connections. More information here. Its source code can be found here: https://github.com/socketio/engine.io "},{"title":"engine.clientsCount​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#engineclientscount","content":"Added in v1.0.0 &lt;number&gt; The number of currently connected clients. const count = io.engine.clientsCount; // may or may not be similar to the count of Socket instances in the main namespace, depending on your usage const count2 = io.of(&quot;/&quot;).sockets.size; Copy "},{"title":"engine.generateId​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#enginegenerateid","content":"&lt;Function&gt; The function used to generate a new session ID. Defaults to base64id. const uuid = require(&quot;uuid&quot;); io.engine.generateId = () =&gt; { return uuid.v4(); // must be unique across all Socket.IO servers } Copy "},{"title":"engine.handleUpgrade(request, socket, head)​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#enginehandleupgraderequest-socket-head","content":"Added in v1.0.0 request &lt;http.IncomingMessage&gt; the incoming requestsocket &lt;stream.Duplex&gt; the network socket between the server and clienthead &lt;Buffer&gt; the first packet of the upgraded stream (may be empty) This method can be used to inject an HTTP upgrade: Example with both a Socket.IO server and a plain WebSocket server: import { createServer } from &quot;http&quot;; import { Server as WsServer } from &quot;ws&quot;; import { Server } from &quot;socket.io&quot;; const httpServer = createServer(); const wss = new WsServer({ noServer: true }); const io = new Server(httpServer); httpServer.removeAllListeners(&quot;upgrade&quot;); httpServer.on(&quot;upgrade&quot;, (req, socket, head) =&gt; { if (req.url === &quot;/&quot;) { wss.handleUpgrade(req, socket, head, (ws) =&gt; { wss.emit(&quot;connection&quot;, ws, req); }); } else if (req.url.startsWith(&quot;/socket.io/&quot;)) { io.engine.handleUpgrade(req, socket, head); } else { socket.destroy(); } }); httpServer.listen(3000); Copy "},{"title":"Event: 'initial_headers'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#event-initial_headers","content":"Added in v4.1.0 headers &lt;Object&gt; a hash of headers, indexed by header namerequest &lt;http.IncomingMessage&gt; the incoming request This event will be emitted just before writing the response headers of the first HTTP request of the session (the handshake), allowing you to customize them. import { serialize } from &quot;cookie&quot;; io.engine.on(&quot;initial_headers&quot;, (headers, request) =&gt; { headers[&quot;set-cookie&quot;] = serialize(&quot;uid&quot;, &quot;1234&quot;, { sameSite: &quot;strict&quot; }); }); Copy If you need to perform some asynchronous operations, you will need to use the allowRequest option: import { serialize } from &quot;cookie&quot;; const io = new Server(httpServer, { allowRequest: async (req, callback) =&gt; { const session = await fetchSession(req); req.session = session; callback(null, true); } }); io.engine.on(&quot;initial_headers&quot;, (headers, req) =&gt; { if (req.session) { headers[&quot;set-cookie&quot;] = serialize(&quot;sid&quot;, req.session.id, { sameSite: &quot;strict&quot; }); } }); Copy See also: how to use with express-sessionhow to deal with cookies "},{"title":"Event: 'headers'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#event-headers","content":"Added in v4.1.0 headers &lt;Object&gt; a hash of headers, indexed by header namerequest &lt;http.IncomingMessage&gt; the incoming request This event will be emitted just before writing the response headers of each HTTP request of the session (including the WebSocket upgrade), allowing you to customize them. import { serialize, parse } from &quot;cookie&quot;; io.engine.on(&quot;headers&quot;, (headers, request) =&gt; { if (!request.headers.cookie) return; const cookies = parse(request.headers.cookie); if (!cookies.randomId) { headers[&quot;set-cookie&quot;] = serialize(&quot;randomId&quot;, &quot;abc&quot;, { maxAge: 86400 }); } }); Copy "},{"title":"Event: 'connection_error'​","type":1,"pageTitle":"Server API","url":"docs/v1/server-api/#event-connection_error","content":"Added in v4.1.0 error &lt;Error&gt; io.engine.on(&quot;connection_error&quot;, (err) =&gt; { console.log(err.req); // the request object console.log(err.code); // the error code, for example 1 console.log(err.message); // the error message, for example &quot;Session ID unknown&quot; console.log(err.context); // some additional error context }); Copy This event will be emitted when a connection is abnormally closed. Here is the list of possible error codes: Code\tMessage0\t&quot;Transport unknown&quot; 1\t&quot;Session ID unknown&quot; 2\t&quot;Bad handshake method&quot; 3\t&quot;Bad request&quot; 4\t&quot;Forbidden&quot; 5\t&quot;Unsupported protocol version&quot; "}]